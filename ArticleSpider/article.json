{"fav_num": 0, "url_object_id": "ab0322e9007276c76fe370fbf4a95a33", "tags": "", "comment_num": 0, "title": null, "praise_num": 0, "image_urls": ["http://jbcdn2.b0.upaiyun.com/2018/01/1b8322e1daff605d71fc81e724421f17.jpg"], "contents": "", "url": "http://blog.jobbole.com/113782/", "image_file_path": "full/14452eea6b79bce0219227f298ad827f2ba7112d.jpg", "pubtime": "2018-2-24"}
{"fav_num": 0, "url_object_id": "c04253a00ce7d51d704df4838a462dc1", "tags": "职场·工程师", "comment_num": 0, "title": "工程师思维，做不出好产品？", "praise_num": 0, "image_urls": ["http://jbcdn2.b0.upaiyun.com/2017/07/15cdc9eaec6ba9ac858b0eaebfb6b949.jpg"], "contents": "这不是一个鸡汤文，也不是警世文，这文章没什么结论和重点，你不会从这篇文章中获得什么领悟。__恭喜你，你选择继续往下看，代表你对这标题也有一定程度的好奇，或许你也有同样的疑惑？__「你的想法太工程师了，不适用在「一般」用户上，怎么可能用一般用户的角度去思考产品呢？」会这样说可能是你就是从事市场或和技术半毛关系都没有的岗位上。__我觉得这个指控实在很莫名其妙，农夫讲出关于种树的话，渔夫讲出关于捞鱼的话，本该是天经地义的事，然后现在我们要进森林开垦，凭什么渔夫说的就是道理，农夫说的就是歪理呢。__况且重点还是，最后要操刀的是农夫啊！__世间上的事，都不是完全都是两极化的对与错，一件事通常面向都会超过一个，就取决于那是站在那一面观看，我要说的正是，软件工程师如何设计好产品。__马云说过一句差不多这样的话，他说：他就是 QA，他不会用的产品，大概就不是什么好产品，因为大部分人都和他一样，是一个不懂技术的人。__就单凭这句话，很多人就会抛开技术思维，抛开一切，就只想自己要做的「大方向」就好，那是当然的，做为一个领导，作为一艘船的导航，确实需要一个明确的方向，大家就尽力前进。但前进的动力来自哪里呢？你可以知道人家背后有多少水手不断研究划船的方法，才可以说出这句那么铿锵有力的话。__「我考第一名，我从来不念书！」__马云那番话字面上理解，那个思维是成立的，但事实上，越是简单的产品，RD 就必须花更多的时间和精力去思考，如果做出「简单」而产品的「直觉和简单」仅仅只是技术演进的结果罢了，千万不要忽略过程。__我只想要飞，就往断崖跳，就肯定会死的。想要飞的心情我理解，但我们能不能坐下来谈谈如何办到「飞」这回事呢？__而越简单的东西，越难做出来。__有一个箱子，里面很冷，食物不会坏；一个箱子，里面有画面，哎！箱子好占空间，做到跟墙一样薄行不行？我想要一个放在口袋的电脑，看到的脸就开锁，啊，要确保一定会开喔，不要让我 demo 的时候开不了。__概念谁都会说，根本不需要花很多时间在这个地方上。__一个好产品，重点是要解决问题，是不是废话？是。__那么要解决问题，要靠技术？还是靠想法？…__你开始质疑自己了吧，你没有马上选技术，或者你选了想法？__因为一般人是不会有这个认知的。你不用怀疑，好产品解决问题的重点，就是技术。不是想法。这两者有什么区别？会讲不会做，就叫做想法；会讲也会做，那是技术。但产品人员最爱放在嘴巴的一句话就是「技术不难，可以做得出来」、「技术可以办到」大部分的概念都是来自于别家产品，至于如何实现，还是一种跟网恋一样的概念，还没见过本人，但是照片看起来还不错。__时至今日要找出，只要好点子，就有好活路的故事太少了，技术突破不了，就是一个「和别人差不多」的东西。既然是差不多，就没有必要多一个，面对消费者，你要怎么说服人家用你家的产品呢？__我写了一大堆都是在靠北，没什么重点，那我先讲一个重点。__「讲 HOW 不要讲 WHAT 和 WHY」__一个组织要做什么事，应该不难决定，那就是一个决定。__试想想，最近我有个朋友在想开餐厅的事，我就默默的观察，他会如何思考开餐厅的流程。__他从菜单一路讲到店面，从行销和定位，说到 SWOT 和五力分析。都还没说到，如何做饭这个点上。虽然只是比喻，但是你可以想像餐厅本身最关键的除了价格，就是味道，好吃！最直接的竞争力，就是要__「HOW 做到很好吃」一个点就好。__而 HOW 的精髓，就是技术（技巧），做菜需要技巧；写程序也需要技巧，如何用什么工具解决什么问题（这是重点，我只是没有特别强调）是很重要的一个概念。__就跟为什么这个控肉饭那么好吃，它是怎么办到的？！靠，那就是靠技术啊，每天做研究啊，研究又试做啊，然后失败又再来啊，不然你以为咧。__至于说，技术本身是没有意义的，除非它用来解决问题。__那就是一个重点了，要讲出问题在哪里（WHAT），和为什么会发生（WHY），即便这些很有可能都是在猜的，要讲出几个点那也不是一件难的差事，只差你愿不愿意面对而已，因为就算你说错了，也没有什么证据证明你是错的，你顶多只能怀疑，这个家伙在胡说。__技术本身是没有意义的，就让我想起一个名人说的话，钱本身是没有意义的，除非你利用它！说到我帐户有几万千还没开始「利用」一样。那个重点不是这句话，重点是我没有钱啊！__技术本身有没有价值，我不好说，但重点是，我们要先研究出技术啊！__而很多时候，我们只需要一个菜单，就那么简单。但是可怕的事还不是没有菜单，而是有菜单还有一叠厚厚的明细，随着不懂做菜的人进厨房，然后还帮你为每个做菜步骤列名时间和顺序，然后当你仔细一看，那个根本不是做菜步骤，是上菜和吃饭的步骤，里面写的跟做菜一点屁关系都没有。__这群人根本不在乎怎么做菜啊。__但不要误会，半点也没有怪他们「为何不关心」做菜这事上。__因为很多时候，甚至极大部分时候，工程师也是不关心如何「上菜」的，也不关心味道如何，只要时间内上菜，老板没有埋怨，客户没有中毒死，更也别说口碑好不好，有的厨师本来就是抱着能吃就好的心情做菜，竟然吃不死，就是好料理啦。__但这主题是说「好产品」就不是能吃就好的东西了，要对味道和整个用餐过程都很有要求。__就算不是五星，也要老板亲切啊，服务态度 UX 要好，UX 不是一个人的工作，UX 是一个团队的工作，一个集体带来的效益。大部分团队就是设计出图，PM 画 flow，RD 写 code；就跟打传说有人坦克，有人输出，有人牵制，但如果要胜出，就可能互相帮打，坦克输出会补刀，输出火力也要帮忙牵制，但是如果规定了坦克就只能挨打，牵制就只能在那边躲起来发功，那就死定了。__分工的结果就如参加一个比赛，的确是顺利的把比赛结束了，但也别想说有什么惊喜的表现。__写程序的人就会用工具了，尤其是前端，现在光是设一个开发环境，就用了一堆东西，有些太久没有用它还更新改版了，有天有个朋友请我帮忙做个事，我就拿着笔电狂 Key，滴滴答答的，一个多小时之后，我就「yeah」喊了一声，他就问「你弄好咯，感谢啦」__我说「还没，但可以开始弄了！yeah」__但我以一个消费者的立场，做出产品，至于好不好，是消费者自己的看法。千万不要一直和我说你东西有多好吃，我自己有嘴巴好嘛！如果不好吃，你和我说一百遍也不会好吃啊。", "url": "http://blog.jobbole.com/112125/", "image_file_path": "full/d6573fc92df4aa98014ce9dc55320411b7b5bf1d.jpg", "pubtime": "2018/03/19"}
{"fav_num": 2, "url_object_id": "1c7d5802b140adefb9805592b6a7e332", "tags": "IT技术·IPv6·Linux", "comment_num": 0, "title": "在 Linux 中自动配置 IPv6 地址", "praise_num": 0, "image_urls": ["http://jbcdn2.b0.upaiyun.com/2018/01/1b8322e1daff605d71fc81e724421f17.jpg"], "contents": "在 __ 一文中，我们学习了关于唯一本地地址unique local addresses（ULA）的相关内容。在本文中，我们将学习如何为 ULA 自动配置 IP 地址。__唯一本地地址unique local addresses（ULA）使用 __ 地址块，它类似于我们常用的 IPv4 的私有地址：__、__、以及 __。但它们并不能直接替换。IPv4 的私有地址分类和网络地址转换（NAT）功能是为了缓解 IPv4 地址短缺的问题，这是个明智的解决方案，它延缓了本该被替换的 IPv4 的生命周期。IPv6 也支持 NAT，但是我想不出使用它的理由。IPv6 的地址数量远远大于 IPv4；它是不一样的，因此需要做不一样的事情。__那么，ULA 存在的意义是什么呢？尤其是在我们已经有了本地链路地址link-local addresses（__）时，到底需不需要我们去配置它们呢？它们之间（LCTT 译注：指的是唯一本地地址和本地链路地址）有两个重要的区别。一是，本地链路地址是不可路由的，因此，你不能跨子网使用它。二是，ULA 是你自己管理的；你可以自己选择它用于子网的地址范围，并且它们是可路由的。__使用 ULA 的另一个好处是，如果你只是在局域网中“混日子”的话，你不需要为它们分配全局单播 IPv6 地址。当然了，如果你的 ISP 已经为你分配了 IPv6 的全局单播地址global unicast addresses，就不需要使用 ULA 了。你也可以在同一个网络中混合使用全局单播地址和 ULA，但是，我想不出这样使用的一个好理由，并且要一定确保你不使用网络地址转换（NAT）以使 ULA 可公共访问。在我看来，这是很愚蠢的行为。__ULA 是仅为私有网络使用的，并且应该阻止其流出你的网络，不允许进入因特网。这很简单，在你的边界设备上只要阻止整个 __ 范围的 IPv6 地址即可实现。__ULA 不像本地链路地址那样自动配置的，但是使用 radvd 设置自动配置是非常容易的，radva 是路由器公告守护程序。在你开始之前，运行 __ 或者 __ 去查看你现有的 IP 地址。__在生产系统上使用时，你应该将 radvd 安装在一台单独的路由器上，如果只是测试使用，你可以将它安装在你的网络中的任意 Linux PC 上。在我的小型 KVM 测试实验室中，我使用 __ 命令把它安装在 Ubuntu 上。安装完成之后，我先不启动它，因为它还没有配置文件：__这些所有的消息有点让人困惑，实际上 radvd 并没有运行，你可以使用经典命令 __ 来验证这一点。因此，我们现在需要去创建 __ 文件。拷贝这个示例，将第一行的网络接口名替换成你自己的接口名字：__前缀（__）定义了你的网络地址，它是地址的前 64 位。前两个字符必须是 __，前缀接下来的剩余部分你自己定义它，最后的 64 位留空，因为 radvd 将去分配最后的 64 位。前缀后面的 16 位用来定义子网，剩余的地址定义为主机地址。你的子网必须总是 __。RFC 4193 要求地址必须随机生成；查看 __ 学习创建和管理 ULAs 的更多知识。__IPv6 转发必须要启用。下面的命令去启用它，重启后生效：__取消注释或者添加如下的行到 __ 文件中，以使它永久生效：__启动 radvd 守护程序：__这个示例在我的 Ubuntu 测试系统中遇到了一个怪事；radvd 总是停止，我查看它的状态却没有任何问题，做任何改变之后都需要重新启动 radvd。__启动成功后没有任何输出，并且失败也是如此，因此，需要运行 __ 去查看它的运行状态。如果有错误，__ 会告诉你。一般常见的错误都是 __ 中的语法错误。__在 Twitter 上抱怨了上述问题之后，我学到了一件很酷的技巧：当你运行 __ 去调试 __ 错误时，你的输出会被换行，然后，你就可以看到错误信息。__现在检查你的主机，查看它们自动分配的新地址：__本文到此为止，下周继续学习如何为 ULA 管理 DNS，这样你就可以使用一个合适的主机名来代替这些长长的 IPv6 地址。__通过来自 Linux 基金会和 edX 的 __ 免费课程学习更多 Linux 的知识。__ ", "url": "http://blog.jobbole.com/113771/", "image_file_path": "full/14452eea6b79bce0219227f298ad827f2ba7112d.jpg", "pubtime": "2018/03/14"}
{"fav_num": 2, "url_object_id": "9f16c4dc5a6cd2f4b07fef3690f49f8b", "tags": "IT技术·Linux", "comment_num": 0, "title": "du 及 df 命令的使用（附带示例）", "praise_num": 0, "image_urls": ["http://jbcdn2.b0.upaiyun.com/2017/05/77d80105fd15f2465894827e23cc4842.jpeg"], "contents": "在本文中，我将讨论 __ 和 __ 命令。__ 和 __ 命令都是 Linux 系统的重要工具，来显示 Linux 文件系统的磁盘使用情况。这里我们将通过一些例子来分享这两个命令的用法。__（disk usage 的简称）是用于查找文件和目录的磁盘使用情况的命令。__ 命令在与各种选项一起使用时能以多种格式提供结果。__下面是一些例子：__该命令的输出将显示 __ 中的所有文件和目录以及显示块大小。__它是 __ 目录的总大小__df（disk filesystem 的简称）用于显示 Linux 系统的磁盘利用率。（LCTT 译注：__ 可能应该是 disk free 的简称。）__下面是一些例子。__上面的命令以人类可读格式显示信息。__ 加上目标目录将以可读格式显示 __ 的信息。__虽然 __ 和 __ 命令有更多选项，但是这些例子可以让你初步了解。如果在这里找不到你要找的东西，那么你可以参考有关命令的 man 页面。__另外，__阅读我的其他帖子，在那里我分享了一些其他重要和经常使用的 Linux 命令。__如往常一样，欢迎你留下评论和疑问，因此在下面留下你的评论和疑问，我会回复你。", "url": "http://blog.jobbole.com/113780/", "image_file_path": "full/d1b17b98748a74826464a08e6d30a4ee1b15b171.jpg", "pubtime": "2018/03/23"}
{"fav_num": 1, "url_object_id": "23b91f36b0e3c52751b33dea744a641b", "tags": "IT技术·机器学习·深度学习", "comment_num": 0, "title": "AI 从业者都会用到的 10 个深度学习方法", "praise_num": 0, "image_urls": ["http://jbcdn2.b0.upaiyun.com/2017/04/ff247977ac3e5237654ad324e8c880ed.jpg"], "contents": "过去十年里，人们对机器学习的兴趣经历了爆炸式的整长。我们几乎每天都可以在计算机程序、行业会议和媒体上看到机器学习的身影。很多关于机器学习的讨论都混淆了“机器学习能做什么”和“人类希望机器学习能做什么”。从根本上讲，机器学习是运用算法从原始数据中提取信息，并用某种类型的模型进行表示，然后使用该模型对一些尚未用模型表示的其他数据来进行推断。__神经网络就是机器学习各类模型中的其中一类，并且已经存在了至少50年。神经网络的基本单位是节点，它的想法大致来源于哺乳动物大脑中的生物神经元。生物大脑中的神经元节点之间的链接是随着时间推移不断演化的，而神经网络中的神经元节点链接也借鉴了这一点，会不断演化（通过“训练”的方式）。__神经网络中很多重要框架的建立和改进都完成于二十世纪八十年代中期和九十年代初期。然而，要想获得较好结果需要大量的时间和数据，由于当时计算机的能力有限，神经网络的发展受到了一定的阻碍，人们的关注度也随之下降。二十一世纪初期，计算机的运算能力呈指数级增长，业界也见证了计算机技术发展的“寒武纪爆炸”——这在之前都是无法想象的。深度学习以一个竞争者的姿态出现，在计算能力爆炸式增长的十年里脱颖而出，并且赢得了许多重要的机器学习竞赛。其热度在2017年仍然不减。如今，在机器学习的出现的地方我们都能看到深度学习的身影。__为了跟上时代的潮流，我参加了 Udacity 的“深度学习”课程。这是一个很好的入门课程，包括深度学习的动机和在 TensorFlow 中针对复杂的和/或大规模数据集进行学习的智能系统的设计。 对于课程作业，我使用和开发了用于图像识别的卷积神经网络，带有嵌入的自然语言处理以及运用递归神经网络/长期短期记忆的基于字符的文本生成程序。所有 Jupyter Notebook 的代码都在我的 __。__下图是课程作业的一个结果，词向量的 t-SNE 投影，通过相似性进行聚类。__最近，我开始阅读关于深度学习的学术论文。根据我的个人研究，以下文章对这个领域的发展产生了巨大的影响：__通过研究和学习，我学到了大量关于深度学习的相关知识。在这里，我想分享人工智能工程师 10 个用于解决机器学习问题的强大的深度学习方法。但是，我们首先需要定义什么是深度学习。__如何定义深度学习是很多人面临的一个挑战，因为它的形式在过去的十年中已经慢慢地发生了改变。下图直观地展示了人工智能，机器学习和深度学习之间的关系。__人工智能领域广泛，存在时间较长。深度学习是机器学习领域的一个子集，而机器学习是人工智能领域的一个子集。一般将深度学习网络与“典型”前馈多层网络从如下方面进行区分：__上文提到的“更多的神经元”是指近年来神经元的数量不断增加，就可以用更复杂的模型来表示。层也从多层网络中每一层完全连接，发展到卷积神经网络中神经元片段的局部连接，以及与递归神经网络中的同一神经元的循环连接（与前一层的连接除外）。__因此，深度学习可以被定义为以下四个基本网络框架中具有大量参数和层数的神经网络：__在这篇文章中，我主要讨论三个框架：__反向传播是一种计算函数偏导数（或梯度）的简单方法，它的形式是函数组合（如神经网络）。在使用基于梯度的方法求解最优化问题（梯度下降只是其中之一）时，需要在每次迭代中计算函数梯度。__对于一个神经网络，其目标函数是组合形式。那么应该如何计算梯度呢？有2种常规方法：（i）__。函数形式已知的情况下，只需要用链式法则（基础微积分）计算导数。（ii）__。这种方法运算量很大，因为函数评估的数量级是 O(N)，其中 N 是参数的个数。与微分解析法相比，这种方法运算量更大，但是在调试时，通常会使用有限差分验证反向传播的效果。__梯度下降的一个直观理解就是想象一条源自山顶的河流。这条河流会沿着山势的方向流向山麓的最低点，而这也正是梯度下降法的目标。__我们所期望的最理想的情况就是河流在到达最终目的地（最低点）之前不会停下。在机器学习中，这等价于我们已经找到了从初始点（山顶）开始行走的全局最小值（或最优值）。然而，可能由于地形原因，河流的路径中会出现很多坑洼，而这会使得河流停滞不前。在机器学习术语中，这种坑洼称为局部最优解，而这不是我们想要的结果。有很多方法可以解决局部最优问题（这里不再讨论）。__因此，由于地形（即函数性质）的限制，梯度下降算法很容易卡在局部最小值。但是，如果能够找到一个特殊的山地形状（比如碗状，术语称作凸函数），那么算法总是能够找到最优点。在进行最优化时，遇到这些特殊的地形（凸函数）自然是最好的。另外，山顶初始位置（即函数的初始值）不同，最终到达山底的路径也完全不同。同样，不同的流速（即梯度下降算法的学习速率或步长）也会导致到达目的地的方式有差异。是否会陷入或避开一个坑洼（局部最小值），都会受到这两个因素的影响。__调整随机梯度下降优化算法的学习速率可以提升性能并减少训练时间。这被称作学习率退火或自适应学习率。训练中最简单也最常用的学习率自适应方法就是逐渐降低学习率。在训练初期使用较大的学习率，可以对学习率进行大幅调整；在训练后期，降低学习率，以一个较小的速率更新权重。这种方法在早期可以快速学习获得较好的权重，并在后期对权重进行微调。__两个流行而简单的学习率衰减方法如下：__拥有大量参数的深度神经网络是非常强大的机器学习系统。然而，在这样的网络中,过拟合是一个很严重的问题。而且大型网络的运行速度很慢，这就使得在测试阶段通过结合多个不同的大型神经网络的预测来解决过拟合问题是很困难的。Dropout 方法可以解决这个问题。__其主要思想是，在训练过程中随机地从神经网络中删除单元（以及相应的连接），这样可以防止单元间的过度适应。训练过程中，在指数级不同“稀疏度”的网络中剔除样本。在测试阶段，很容易通过使用具有较小权重的单解开网络（single untwined network），将这些稀疏网络的预测结果求平均来进行近似。这能有效地避免过拟合，并且相对于其他正则化方法能得到更大的性能提升。Dropout 技术已经被证明在计算机视觉、语音识别、文本分类和计算生物学等领域的有监督学习任务中能提升神经网络的性能，并在多个基准数据集中达到最优秀的效果。__最大池是一种基于样本的离散化方法。目标是对输入表征（图像、隐藏层输出矩阵等）进行下采样，降低维度并且允许对子区域中的特征进行假设。__通过提供表征的抽象形式，这种方法可以在某种程度上解决过拟合问题。同样，它也通过减少学习参数的数目以及提供基本的内部表征转换不变性来减少计算量。最大池是通过将最大过滤器应用于通常不重叠的初始表征子区域来完成的。__当然，包括深度网络在内的神经网络需要仔细调整权重初始值和学习参数。批量标准化能够使这个过程更加简单。__在反向传播过程中，这些现象会导致梯度的偏移，这就意味着在学习权重以产生所需要的输出之前，梯度必须补偿异常值。而这将导致需要额外的时间才能收敛。__批量标准化将这些梯度从异常值调整为正常值，并在小批量范围内（通过标准化）使其向共同的目标收敛。__通常来说，学习率都比较小，这样只有一小部分的梯度用来校正权重，因为异常激活的梯度不应该影响已经学习好的权重。通过批量标准化，这些异常激活的可能性会被降低，就可以使用更大的学习率加速学习过程。__长短期记忆网络（LSTM）和其他递归神经网络中的神经元有以下三个不同点：__LSTM的强大之处在于它可以只基于当前的输入就决定上述所有。请看下方的图表：__当前时间戳的输入信号 x(t) 决定了上述三点。输入门（input gate）决定了第一点，遗忘门（forget gate）决定了第二点，输出门（output gate）决定了第三点。只依赖输入就可以完成这三项决定。这是受到大脑工作机制的启发，大脑可以基于输入来处理突然的上下文语境切换。__词嵌入模型的目的是针对每个词学习一个高维密集表征，其中嵌入向量之间的相似性显示了相应词语之间语义或句法的相似性。Skip-gram 是一种学习词嵌入算法的模型。__skip-gram 模型（包括很多其它词嵌入模型）背后的主要思想是：__换句话说，假设有一个句子，比如“cats are mammals”，如果用“dogs”替换“cats”，该句子仍然是有意义的。因此在这个例子中，“dogs”和“cats”有相似的上下文（即“are mammals”）。__基于以上假设，我们可以考虑一个上下文窗口（包含 K 个连续项）。然后跳过其中一个词，试着学习一个可以得到除了跳过的这个词以外所有词项，并且可以预测跳过的词的神经网络。因此，如果两个词在一个大语料库中多次具有相似的上下文，那么这些词的嵌入向量将会是相似的。__在自然语言处理中，我们希望将文档中的每一个单词表示为一个数值向量，使得出现在相似上下文中的单词具有相似或相近的向量表示。在连续词袋模型中，我们的目标是利用一个特定单词的上下文，预测该词。__ __首先在一个大的语料库中抽取大量的句子，每看到一个单词，同时抽取它的上下文。然后我们将上下文单词输入到一个神经网络，并预测在这个上下文中心的单词。__当我们有成千上万个这样的上下文词汇和中心词时，我们就得到了一个神经网络数据集的实例。然后训练这个神经网络，在经过编码的隐藏层的最终输出中，我们得到了特定单词的嵌入式表达。当我们对大量的句子进行训练时也能发现，类似上下文中的单词都可以得到相似的向量。__我们来考虑一下卷积神经网络是如何处理图像的。假设有一张图像，对其应用卷积，并得到像素的组合作为输出。假设这些输出是边缘，再次应用卷积，那么现在的输出将是边缘或线的组合。然后再次应用卷积，此时的输出将是线的组合，以此类推。可以把它想象成是在每一层寻找一个特定的模式。神经网络的最后一层通常会变得非常特别。如果基于 ImageNet 进行训练，那么神经网络的最后一层或许就是在寻找儿童、狗或者飞机之类的完整图像。再往后倒退几层，可能会看到神经网络在寻找眼睛、耳朵、嘴巴或者轮子等组成部分。__深度卷积神经网络中的每一层逐步建立起越来越高层次的特征表征，最后几层通常是专门针对输入数据。另一方面，前面的层则更为通用，主要用来在一大类图片中有找到许多简单的模式。__迁移学习就是在一个数据集上训练卷积神经网络时，去掉最后一层，在不同的数据集上重新训练模型的最后一层。直观来讲，就是重新训练模型以识别不同的高级特征。因此，训练时间会减少很多，所以在没有足够的数据或者需要太多的资源时，迁移学习是一个很有用的工具。__本文只是简单地对这些方法进行了概述，若想深入理解，建议继续阅读以下文章：__深度学习是非常注重技术实践的。本文对每个新想法都没有太多具体的解释。大多数新想法的提出都会附带实验结果以证明它们的可行性。学习深度学习就像玩乐高，玩好乐高和掌握其他艺术一样具有挑战性，但是入门就相对容易很多的。", "url": "http://blog.jobbole.com/113740/", "image_file_path": "full/eadb28355fab57e9672e5c965147ef4caca04ac4.jpg", "pubtime": "2018/03/12"}
{"fav_num": 1, "url_object_id": "7a3fd4e360713292fb09393642fffc46", "tags": "职场·游戏", "comment_num": 0, "title": "从业 24 年独立开发者：大多数同行都只看 5 年以内", "praise_num": "1", "image_urls": ["http://jbcdn2.b0.upaiyun.com/2018/03/db3f0f9a2c81173f5758eed4074b7543.jpg"], "contents": "GameLook报道/有人说，游戏行业的竞争越来越激烈，游戏数量的增加使得曝光率问题日益严重，但在Jeff Vogel看来，真正热爱游戏研发的人，是不会抱怨这些问题的，因为大多数人做开发者都是从1-5年的时间看待自己的游戏研发职业生涯，而真正想要把游戏当作职业的人，往往是考虑40年或者更长的周期。__在24年的独立游戏研发生涯中，Spiderweb Software创始人Jeff Vogel学到了很多东西。在3月20日举行的GDC独立游戏峰会上，他分享了一些自己的心得，有些观点让人十分意外。__Vogel强调，“游戏行业还是个朝阳产业，没有人无所不知，我们还有很多东西都需要弄明白，比如，如何设计这些游戏，如何创造、测试以及销售这些产品，如何为游戏做营销，如何给1亿美元预算的项目增加开箱子玩法而又不影响发布之后的口碑？”他提到自己的第一个游戏项目时候说，“这个项目并没有耗时太久，我当时有了一个想法，也就是小时候就喜欢的那些游戏，所以我要做的就是把小时候喜欢的游戏都回顾一遍，然后从每个游戏里汲取最好的创意。按照我的方法，我希望把它们变成让我觉得满意的游戏”。__Jeff Vogel的第一款游戏截图__独立游戏非常适合做创新，但创新并不是唯一的出路。你必须知道，我们游戏行业的每个人都是站在巨人的肩膀上，所有的玩法都是在原有的玩法之上演变而来，我只了解自己喜欢的，然后复制这个想法，这就是我的创意过程，他鼓励其他开发者们用类似的方式，按照自己的个人需求去寻找创意，有人把游戏创意说的很玄，比如追求自己的灵感，这样的建议，但我的建议是千万不要这样做，这是一个非常现实的建议，我来说说原因。__大多数人思考自己在游戏行业生涯的时候，往往是从1-5年的角度考虑问题，对于一些刚开始做游戏研发的人们来说，追寻自己的灵感似乎是非常合理的事情。但是，如果你把自己从事独立游戏研发行业的期限延长到40年或者更久的时间考虑，或许会有所帮助。__这是一个特别长的时间，如果你在一个行业工作这么久，就会达到最高的工作效率，因为你需要维持生存，需要一个对应的生活方式，一个长久的想法，一个可持续的过程，保持自己不至于破产，因为，如果你因为一些想法而失去了立足之本，在接下来的40年里，它都会让你不断吃亏。__当然，Vogel的创意也并不只是抄袭其他游戏的玩法，他对自己游戏的要求也是相对较高的，比如研发续作的时候，前作25%最差的部分需要被替换，提高整体游戏质量。他非常喜欢重复使用资源、代码和引擎，并认为所有人都不应该因此感到羞辱，比如有一个狼的icon，他在15款不同的游戏里使用过，“人们一直拿这个梗开我的玩笑，但我还是没有因此失业”。__虽然Spiderweb的游戏有一定的用户群，而且口碑还不错，但这些游戏对于更大的用户群缺乏吸引力，有很大一部分原因是画质无法和3A游戏媲美，但Vogel说，“我非常反感所有人吐槽我的画面质量不够好，我也是投入了资金，专门招聘了美术师的，有些美术资源也是从比较大的渠道获得的，然而还是有人经常说，我的游戏画面很差，我以后再也不会浪费精力去专门提高美术质量了”。__对于独立游戏开发者而言，这种批评的声音也是经常遇到的，人性有一部分是刻薄的，会对某些事物提出不合理的需求，而且在Steam这样的分销平台没有出现之前，Vogel做电话销售的时候就遇到过类似的问题。而到了互联网时代，这种问题就更加严重，“通常最愤怒的人不是完全匿名的，他们可能是五年前你的游戏最忠实的粉丝，然后你对游戏做出了改变，而且改掉的恰好是他们最喜欢的东西，他们就不再是你的粉丝，你要知道，有时候爱与恨之间的界限很小”。__作为一个想要长期在游戏行业生存的开发者，Vogel表示，远离各种形式的骚扰是很重要的，作为一个成年人，虽然你很少会被人轻易激怒，但仍有很多事情会让你抓狂，所以Vogel基本上不会看自己的游戏在Steam平台的评论，也不访问论坛，如果被人喷，他还会暂时不登陆Twitter，等待事情平息了之后再登录，如果与一些玩家的关系闹僵，他会毫不犹豫的放弃这部分用户。Vogel说，“不要怕得罪用户，他们说客户总是对的，但实际上并非如此，用户一直是错的。但差别在于，你永远吵不赢他们。有时候你不得不对一部分玩家说，‘我的游戏不适合你，所以我不能增加你要的功能、不能做这样的资料片、不能满足你的要求’，对于你无法让他们满意的用户，退款是最好的方法”。__《Geneforge 3》截图__对于论坛管理，他说，“如果有人在论坛挑事，直接封掉就是了。但如果有人说，‘这些人又不会影响你的生意，不应该封他们’，那你可以连这些人一起封掉，这些消极的负面声音只会给你的社区带来不利影响，真正支持你的玩家会理解你的做法”。__和所有的工作室一样，Spiderweb也经历了起伏，Vogel指出，2004年是最艰难的时候，那一年他的两款游戏，《Blades of Avernum》和《Geneforge 3》的销量都不佳。__有人说，游戏开发者就像是艺术家，遭遇挫折在所难免，但Vogel认为，作为艺术家，你必须成长，“我们更像是玩具制造者，我们卖的是娱乐体验，我们的作品是用来给人们的大脑带来消遣的，我们卖的是惊喜，而自满、平淡无奇和重复会扼杀惊喜。如果你想做续作，很好，但你的续作最好是加入一些新东西，而且是越早越好，因为，如果玩家们开始发现你的需走只是重复，那么就会以拒绝购买的方式让你看到他们的答案”。__最后，Vogel还提醒同行们不要过度消耗自己的健康，“不要因为熬夜工作而感到自豪，你需要睡眠才能活的长久，最好是挑一把好的椅子，因为有一天如果你的脊椎不行了，就会追悔莫及”。", "url": "http://blog.jobbole.com/113778/", "image_file_path": "full/e987a29d5f8519c5dcfb6963d8ba061ebf03b879.jpg", "pubtime": "2018/03/22"}
{"fav_num": 0, "url_object_id": "346c3258b4b9bfbca9483337a14be393", "tags": "IT技术·Code Review·代码审查", "comment_num": 0, "title": "我从 1000 份代码审查中学到了什么", "praise_num": 0, "image_urls": ["http://wx3.sinaimg.cn/mw690/63918611gy1fpaca90vycj218g0tmtek.jpg"], "contents": "我看到有些建议不断重复出现，所以我决定整理一个清单，与诸位分享。__这是我的 3（额外 +1）个最常见的代码审查建议。__我见过的一个常见模式是：__这种模式实际上导致了我做的移动应用程序崩溃，我们当时使用的搜索后端开始抛出异常。而应用程序的 API 服务器中也有一些类似的代码。从应用程序的角度来看，它成功获取了 200 个响应，只是每个搜索请求返回的是空列表。__如果当时 API 直接抛出异常，那么我们的监控系统就会立即检测到并修复它。__很多时候，当你捕获一个异常时，你会希望它返回一个空对象。Java 中的空对象包括 Optional.empty()、null 和空列表，而它们在 URL 解析中经常出现。如果 URL 不能从一个字符串中正确解析时，先不要返回 null，而是停下来问问自己：“为什么 URL 格式不正确？这不是我们应该在上游解决的数据问题吗？”__空对象不是解决此类问题的合适工具。__这个建议基本上与__相反。__我经常看到类似这样的代码：__尽可能具体的类型可以让你避免整个类的错误，这基本上是大家选择强类型语言（如 Java）的原因。__所以现在的问题是：那些想要写强类型语言的程序员，最终是怎么写出糟糕的字符串类型的代码哪？答案是：因为外部世界不是强类型的。字符串通常来自许多不同的地方，比如：__这些情况下，你应该使用以下策略来避免这个问题：__。这是一个例子：__它带给我们许多好处：1、能够立刻发现格式不正确的数据；如果有任何问题，应用程序会提前显示并终止。2、一旦数据通过验证，你不必在整个应用程序中捕获解析异常。3、强类型使得签名具有更多信息，这样你就无需在每个方法上写 javadoc。__（可选）类是 Java 8 中最好的特性之一，它表示一个可以合理存在或不存在的实体。__问题时间：唯一用缩写来指代的异常是什么？答：NPE （Null Pointer Exception，空指针异常）。这是迄今为止 Java 中最常见的异常，被称为__。__ 允许你从程序中完全删除 NPE。但是，你必须正确地使用它。这里有一些关于如何使用 __ 的建议：__你应该尽量避免类似的方法：__所有要避免的方法有什么共同点？他们都使用容器对象，比如 Optional，List 或 Task 作为方法的参数。当返回类型是同一类型的容器（即，一个参数的方法采用 Optional 并返回一个 Optional），情况会变得更糟糕。__为什么？__相比 ① __，② __更具有灵活性。__如果你有 __，那么你可以使用 ①，也可以通过  __ 函数“提升（lifting）” （比如 __）来使用 ②.__但是，如果你只有 B，那么你可以很容易地使用 ②，却不能使用 ①，很明显，② 是一个更灵活的选择。__我喜欢称之为“Unlift”，因为它与普通函数的实用方法“Lift”恰好相反。应用这些重写能使方法更灵活，调用更轻松。", "url": "http://blog.jobbole.com/113741/", "image_file_path": "full/72fd692cdd9ccd44d3da74f6eda1119635b48c27.jpg", "pubtime": "2018/03/12"}
{"fav_num": 0, "url_object_id": "1401d80b943d81d3493c295bfe34a3ab", "tags": "IT技术·Linux", "comment_num": 0, "title": "Linux 新用户？来试试这 8 款重要的软件", "praise_num": 0, "image_urls": ["http://jbcdn2.b0.upaiyun.com/2018/01/1b8322e1daff605d71fc81e724421f17.jpg"], "contents": "即便您不是计算机的新手，刚接触 Linux 时，通常都会面临选择使用应用软件的问题。在数百万 Linux 应用程序中，做起选择来并不轻松。本文中，您将能发现八个重要的 Linux 应用，帮助您快速选择应用程序。__下面这些应用程序大多不是 Linux 独有的。如果有过使用 Windows/Mac 的经验，您很可能会熟悉其中一些软件。根据兴趣和需求，下面的程序可能不全符合您的要求，但是在我看来，清单里大多数甚至全部的软件，对于新用户开启 Linux 之旅都是有帮助的。__ : __几乎不会不需要使用网页浏览器的用户。您可以看到陈旧的 Linux 发行版几乎都会附带 Firefox（火狐浏览器）或者其他 __，关于浏览器，强烈建议您尝试 __。它是谷歌浏览器的开源版。Chromium 的主要优点是速度和安全性。它同样拥有大量的附加组件。__ 是一个开源办公套件，其包括文字处理（Writer）、电子表格（Calc）、演示（Impress）、数据库（Base）、公式编辑器（Math）、矢量图和流程图（Draw）应用程序。它与 Microsoft Office 文档兼容，如果其基本功能不能满足需求，您可以使用 __。__LibreOffice 显然是 Linux 应用中至关重要的一员，如果您使用 Linux 的计算机，安装它是有必要的。__ 是一款非常强大的开源图片处理程序，它类似于 Photoshop。通过 GIMP，您可以编辑或是创建用于 Web 或是打印的光栅图（位图）。如果您对专业的图片处理没有概念，Linux 自然提供有更简单的图像编辑器，GIMP 看上去可能会复杂一点。GIMP 并不单纯提供图片裁剪和大小调整，它更覆盖了图层、滤镜、遮罩、路径和其他一些高级功能。__ 也许就是最好的影音播放器了。它是跨平台的，所以您可能在 Windows 上也听说过它。VLC 最特殊的地方是其拥有大量解码器（并不是所有的解码器都开放源代码），所以它几乎可以播放所有的影音文件。__ 完全是关于通讯的。您可以借助它使用 Google talk、Facebook chat、Yahoo、ICQ 和 XMPP。它是用于音视频通话（包括电话会议），桌面流desktop streaming和群组聊天的多用户工具。会话会被加密。Jistsy 同样能帮助您传输文件或记录电话。__ 是一款基于 Debian 系统发行版的另一款应用程序安装程序。并不是所有基于 Debian 的 Linux 都安装有它，如果您使用基于 Debian 的 Linux 操作系统没有预装，也许您可以试一试。Synaptic 是一款用于添加或移除系统应用的 GUI 工具，甚至相对于许多发行版默认安装的 __ ，经验丰富的 Linux 用户更亲睐于 Sunaptic。__ : __ 能支持您在计算机上运行虚拟机。当您想在当前 Linux 发行版上安装其他发行版或操作系统时，使用虚拟机会方便许多。您同样可以通过它运行 Windows 应用程序，性能可能会稍弱，但是如果您有一台强大的计算机，就不会那么糟。__对于 Linux 的新用户来说，一款纸牌游戏并不是刚需，但是它真的太有趣了。当您进入这款纸牌游戏，您会发现，这是一款极好的纸牌游戏包。__ 是 Linux 标志性的应用程序，原因是 – 它涵盖超过八十种纸牌游戏，包括流行的 Klondike、Bakers Dozen、Camelot 等等，作为预警 – 它是会上瘾的，您可能会花很长时间沉迷于此！__根据您所使用的发行版，这些软件会有不同的安装方法。但是大多数都可以通过您使用的发行版中的包管理器安装使用，甚至它们可能会预装在您的发行版上。安装并且尝试它们想必是最好的，如果不合您的胃口，您可以轻松地删除它们。__ ", "url": "http://blog.jobbole.com/113775/", "image_file_path": "full/14452eea6b79bce0219227f298ad827f2ba7112d.jpg", "pubtime": "2018/03/21"}
{"fav_num": 3, "url_object_id": "a47361c034c83e65bad8c6c27ce61a3b", "tags": "IT技术·Redis·数据库", "comment_num": 0, "title": "Redis 集群部署及踩过的坑", "praise_num": 0, "image_urls": ["http://jbcdn2.b0.upaiyun.com/2016/04/49961db8952e63d98b519b76a2daa5e2.png"], "contents": "要在单台机器上搭建Redis集群，方式是通过不同的TCP端口启动多个实例，然后组成集群，同时记录在搭建过程中踩过的坑。__centos版本：6.7__redis版本：3.2.3__安装方式：源码安装__服务器：1台__此处默认已安装好单台redis，如果不会可以参照《__》__ __我们在Redis安装目录下创建目录cluster，并编写7000.conf~7005.conf 6个配置文件，这6个配置文件用来启动6个实例，后面将使用这6个实例组成集群。__以7000.conf为例，配置文件需要填写如下几项：__分别启动6个实例__启动成功后，看一下进程__至此，ip=192.168.186.91机器上创建了6个实例，端口号为port=7000~7005。__ __这一步骤中出现了bug,度娘告诉我是Ruby版本太低，需要升级版本。__安装rvm，我不知道这是个什么东西，但是感觉像是Ruby的一个包管理器。__这一操作得到了：__gpg2 –recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3__然后利用该密钥下载Ruby并升级。__接着，source环境，让rvm可用。__查看Ruby可用版本__可以看到最新的版本是2.4.1，本文安装2.3.0__至此，我们升级了Ruby的版本。__到目前为止，我们的Ruby和运行redis-trib.rb需要的环境安装完成了。__ __有了Ruby执行环境，可以开始将之前的6个实例组建成集群了。__有三个master，有三个是slave。 后面跟上6个实例就好了，形式就是ip:port__【此处有坑】__第一坑__需要将redis-trib.rb复制到/usr/local/bin目录下。__第二坑__踩完第一坑后，继续执行，发现了第二坑，还好有度娘，但是网上各种说法都有（主要参照了《__》的博客），发现错误的原因是redis数据库没有清除。__第三坑__还是度娘靠谱，在《__》博客中找到了答案。__这是由于之间创建集群没有成功,需要将nodes.conf和dir里面的文件全部删除。__然后重启redis服务。__ __登录集群客户端，-c标识以集群方式登录__查看集群状态", "url": "http://blog.jobbole.com/113760/", "image_file_path": "full/c766feed221138f7946130756cddfc7e86e388b4.jpg", "pubtime": "2018/03/13"}
{"fav_num": 3, "url_object_id": "c8f7206fc12fb03862d494d19208fd22", "tags": "职场·程序员·职场", "comment_num": 0, "title": "程序员如何规划职业路线？", "praise_num": 0, "image_urls": ["http://jbcdn2.b0.upaiyun.com/2017/03/4f255bd43f956c3db484a99d448b198e.jpg"], "contents": "社区中并不缺少有关软件工程师职业发展的文章，甚至可以说是泛滥。很多人都能在这个话题上说两句，三五年工作经验的编程老鸟也好，架构师也好，技术 VP 也好，CTO 也好，都有各自的看法与实践经验。没有哪一套方法是适用于所有人的，这一套软件工程师职业发展纲要，也不过是在你踽踽前行的路上，迷茫时可用来参考借鉴。你的核心竞争力，永远是你的自身实力。切记！__众所周知，软件工程师要做的工作就是写代码，准确地说，你的目标应该是写出满足业务需求并且无法找出 Bug 的代码，而不是写一大堆没用的文字。既然你的任务是写出高质量的代码，那么你首先应该训练的就是打字速度，你需要掌握键盘盲打技能，甚至还要爱上你的“编码神器”，并做到将此工具的用法烂熟于心，闭上眼睛都能正确敲中你想要的快捷键。__当你完全驾驭了计算机的输入设备以后，你需要进一步了解计算机的内部工作原理，不是让你把机器大卸八块，而是你需要全面了解计算机的组成结构与工作原理。如果你不是计算机科班出生也没关系，在网上买一本关于计算机组成原理的书自学即可。你无需做到精通，能全面了解即可，因为接下来你需要在编程的世界中，慢慢去体会计算机的工作感受，你就是计算机的管理者。__好了，现在是时候学习一门编程语言了，最好的选择是 Java，为什么呢？原因很简单，因为市场需求量最大，我敢保证，你学 Java 肯定比学 PHP 更容易找到工作（希望 PHP 程序员们淡定一些，其实我始终认为 PHP 是世界上最好的编程语言）。当你在学习 Java 时，首先需要掌握它啰里吧嗦的编程语法，此时没有什么比写一个“Hello World”来得更爽快一些。随后你需要深刻理解的是 Java 的面向对象概念（每次我说到面向对象，总会被一些单身汉吐槽，其实我想说，对象是可以 new 出来的），这些概念看上去比较虚，但是它们却能撑起一个强大的软件架构。所以，在面向对象技术上面花再多功夫都不为过，因为它能训练我们对业务的抽象能力，就像当初我们学习数学一样，它能训练我们的逻辑思维能力。__看书、看视频、看源码、看技术文档，其实这些都是较为低效的学习方法，掌握编程技能的捷径就是拜一位资深的程序员为师，你可以尊称他为“码神”，记得一定要把他伺候好，让他愿意传授一些编程技能给你，其实也就是一个微笑外加一顿小龙虾的事情，他就能被你征服。一定要看他写的代码，思考为什么他会这样写，一定要将你不理解的地方记录下来，并且在下班之前紧紧地抓住他，让他一次给你讲个够，此时你一定会有一种打通任督二脉的畅快之感。所谓“师傅领进门，修行在个人”，你需要比你师傅更加努力，甚至十倍于他人的付出，才能在编程之路上尝到甜头。此时你需要学习更加高深的武功，研究更加优秀的源码，实践更有挑战的项目，还需要花整块时间，系统地看技术文档以及技术参考书。假如你想成为架构师，不妨看看我所著的《架构探险》这本书，也许它会对你的专业技能有所帮助。__你最好要让自己变成一位豁达开朗之人，千万不要吝啬，一定要懂得分享你所学的专业技能。可以尝试做点自己的开源项目，并让这个开源项目变得更加开放，不妨结合开源，写点技术博客，并厚着脸皮给你身边的朋友阅读。这件事情一定要持之以恒，不要担心有人吐槽你，你肯定会被吐槽，那是因为大家在关注你，此时你需要更加努力，让自己变得足够专业。当你成为真正的“大神”时，就不会有人再吐槽你了，他们只会吐槽自己的技术不如你，此时你将得到的是无限的膜拜和称赞。相信我，这绝不是奇迹。在学习专业技能之路上，多一点自信，多一点勤奋，多一点思考，再争取一点机会，你就会成功。__如果将专业技能比喻为“硬技能”，那么在我们的职场中，与专业性无关的技能就可以归纳为“软技能”了。但每当我提到软技能时，难免会让人误解为这是“务虚”的一种功夫，我们虽然是“吃软饭的”（做软件开发的），但我们却十分讨厌虚伪。没错！我也很厌恶虚伪之人，尤其是在职场中遇到这样的人物，我从心底鄙视他们，但我从来不会和他们发生任何冲突，反而还能和他们愉快地共事，这种本领靠的就是软技能。__软件工程师每天都在和机器打交道，机器是没有感情的，你告诉它是0，它一定不会认为是1。但我们与人打交道却不一样，你告诉他是真，他却可能认为是假。与人打交道，正是软件工程师们最为欠缺的方面，有些软件工程师甚至害怕与人交流，害怕在公开场合讲话，害怕抛头露面，害怕做一些组织性的工作。如果你也有以上这些心里负担，那么恭喜你！因为你即将从本文中找到克服这些困难的灵丹妙药，至少我希望是这样。__需要强调的是，软技能是一种职场必备的核心技能，我敢直言，如果缺乏这方面的技能，你的职业生涯将会变得非常糟糕。软技能包括的方面非常广泛，沟通、协调、组织、气场这些都是最基本的软技能，甚至情商也是一种软技能，会不会讲话，听不听得明白，这些都是软技能。那么我们不妨先从沟通这项软技能开始吧，因为我认为他是软件工程师最重要的软技能之一。__很多人都容易将沟通理解为讲话，说一个人语言很流利，很会讲话，口若悬河，夸夸其谈，其实并非他的沟通能力很强。我认为，沟通可以理解为两方面，即“沟”和“通”。“沟”指的是你将心中所想很清晰地表达出来给对方听，考验的是你的表达能力；“通”指的是让你确信对方是否真明白你所表达的意思，考验的是你的倾听能力。所以，我们很多时候都是在“沟”，往往忽略了“通”，从而形成了“沟而不通”的情况，因此，现在全世界人民都在提倡如何“有效沟通”。还是用一个示例来说话吧。__当领导交给你一项棘手的工作，但你不知道如何开始进行这项工作，此时你应该如何应对当前的挑战呢？绝大多数人会硬着头皮去做，他们希望通过自己的努力，可以顺利完成任务，但结果往往却无法让领导满意。少数人会主动向领导咨询，以寻求领导对自己的帮助。此时应该如何与领导对话呢？似乎并非很多人都清楚。下面这段话是我的套路，仅供参考。__我：勇哥（他是我的领导），最近我遇到了一点麻烦的事情，想听听您的看法（勾起领导的兴趣，让他认真听我说下去，记得一定要说“您”，而不是“你”）。__领导：哦？说来听听（证明领导此时不忙，他有时间让我占用，如果他此时很忙，你应该能感受出来的）。__我：感谢您对我的信任，昨天您交给我一项任务，回到家我一直都在想这项任务，我在想……（一定要对领导表示感激，是他给了我这次锻炼自己的机会，并强调我是“回到家”都在思考，而不是只在在公司里思考，道理你懂的）__领导：可能是我没说清楚，你把这项任务想复杂了，其实……（可见这是一位 nice 的领导，跟着他，你能学到很多东西）__我：我还想再清楚一下，您期待这项工作的结果是怎样的？（一定要明确领导想要的结果，他只会为结果买单）__领导：我希望……（领导娓娓道来，此处省略1万字，你千万不要打断领导的讲话，他讲累了自然就会停，你只需要认真听他怎么讲）__我：好的，我明白了，您希望我……（一定要学会复述领导讲过的话，而且要用自己的理解来表达，不要当复读机）__领导：没错，就是这样。（领导表示认可了，此时你应该表示给领导一个微笑，让他感到欣慰）__我：感谢勇哥！如果我在执行过程中遇到问题，可以再向您请教吗？（一定要感谢，而且要表现出虚心向领导请教，为下一次求救做好准备）__领导：当然，随时交流。（你真心拿他当领导，他才会无条件帮助你，你不懂得用好这位领导，那是你自己的损失）__沟通是不是很有趣？其实沟通是一门学问，我们花一辈子时间都在学习，都在改进自己的沟通方式，目的仅为愉快地和身边的人一起“玩耍”，让此生感到愉悦。__当你已经掌握了必备的专业技能，也具备了让你脱颖而出的软技能，那么接下来你将思考的是自己该走那条路了，继续做软件工程师，还是做软件工程师的 leader？下面这段话将告诉你答案。__首先要澄清的是：我并非职业导师，更不是人生教父，所有的路都由你自己选择，我的责任是告诉你，我认为行之有效的方法。__当你正走在职场的十字路口徘徊，思考走技术，还是走管理？我的答案只有一个：根据你自己的优势来决定。合理利用好自己的优势，会让自己走的更加顺畅，让自己无怨无悔。还是举一个例子来说明吧。__前段时间有位朋友在微信上私聊我，他也遇到了这个问题，继续做技术，还是转管理？我当时是这样问他的，但我希望你可以用这样的方式来问自己。__我：你工作多久了？__朋友：时间不长，写了10年的代码。__我：那相当资深啊，现在还对写代码有激情吗？__朋友：喜欢写，周末有时都会宅在家里写。__我：那你还在纠结什么呢？__朋友：我都工作10年了，身边的人要么当 CTO，要么做总监，自己却还在撸代码，我现在到底该不该转管理？__我：你为什么会考虑转管理？说说你在管理上的优势吧。__朋友：我觉得自己对技术有一定深度，可以帮助团队解决一些技术难题。__我：如果你团队中有位小伙伴遇到一个很棘手的技术问题，没辙了，你会做些什么？__朋友：撸起袖子，就地帮他解决掉。__我：建议你走技术专家路线，这条路也许更加适合你。__朋友：……__当我们在纠结是否应该转管理时，不妨首先理解一下什么是管理？以及什么是管理者？只有当我们正确理解了这些概念以后，再来思考自己是否具备这样的特征，才能顺利帮助自己转型。__管理（management）是协调和监督他人的工作，从而使他人的工作可以有效率且有成效地完成。效率（efficiency）指的是以尽可能少的投入，以获得尽可能多的产出，效率常常被说成“正确地做事”，即不浪费资源。成效（effectiveness）常常被称为“做正确的事”，即做那些可以实现目标的工作活动。管理者（manager）就是完成所有管理工作，并使组织目标能够实现的人。管理者的工作包括计划（planning）、组织（organizing）、领导（leading）和控制（controlling）四种职能。__以上都是管理学告诉我们的知识，如果你想成为一名管理者，那么你必须首先正确理解这些概念的真实含义，才能完全驾驭管理者的岗位，否则你会从管理岗位上摔下来，自己一定伤得不轻。__如果你想成为一名优秀的管理者，那么你需要做些什么呢？__如果团队和你共事过，那么团队应该觉得他们是幸运的，因为你能够让他们更加愉快和高效地工作。__不论选择技术还是管理，在任何时候都不要放弃你的硬技能，因为它是你的“生存之本”，同时你也需要具备强大的软技能，因为它是你的“发展之源”。__学习硬技能其实是有捷径的，你无需一味地学习这些知识点，更多的其实是与人交流以及加以应用。软技能其实是可以训练的，你只需抓住一切可以抓住的机会，有意识地加以训练和反思，你就能悟出很多宝贵的经验。软件开发是一门艺术，你需要能够静得下心，不断地优化和雕琢你的作品，因此你需要具备工匠精神。如果你想成为一名工匠领袖，那么你就应该比他人思考得更多、更高、更深、更全面，你需要更多的软技能。你只有认识到自己的优势，才能正确地选择自己的职业路线。__祝你成功！", "url": "http://blog.jobbole.com/112048/", "image_file_path": "full/d102994dcc342e0686843d89a7518432502d5ff3.jpg", "pubtime": "2018/03/13"}
{"fav_num": 2, "url_object_id": "44f879688ac007f05bd74cdf86522e39", "tags": "IT技术·Linux", "comment_num": 0, "title": "给 “rm” 命令添加个“垃圾桶”", "praise_num": 0, "image_urls": ["http://jbcdn2.b0.upaiyun.com/2017/05/77d80105fd15f2465894827e23cc4842.jpeg"], "contents": "人类犯错误是因为我们不是一个可编程设备，所以，在使用 __ 命令时要额外注意，不要在任何时候使用 __。当你使用 __ 命令时，它会永久删除文件，不会像文件管理器那样将这些文件移动到 “垃圾箱”。__有时我们会将不应该删除的文件删除掉，所以当错误地删除了文件时该怎么办？ 你必须看看恢复工具（Linux 中有很多数据恢复工具），但我们不知道是否能将它百分之百恢复，所以要如何解决这个问题？__我们最近发表了一篇关于 __ 的文章，在评论部分，我们从用户 Eemil Lgz 那里获得了一个关于 __ 脚本的更新，它可以帮助我们将文件移动到“垃圾箱”而不是永久删除它们。__将文件移动到“垃圾桶”是一个好主意，当你无意中运行 __ 命令时，可以拯救你；但是很少有人会说这是一个坏习惯，如果你不注意“垃圾桶”，它可能会在一定的时间内被文件和文件夹堆积起来。在这种情况下，我建议你按照你的意愿去做一个定时任务。__这适用于服务器和桌面两种环境。 如果脚本检测到 GNOME 、KDE、Unity 或 LXDE 桌面环境（DE），则它将文件或文件夹安全地移动到默认垃圾箱 __，否则会在您的主目录中创建垃圾箱文件夹 __。__ 脚本托管在 Github 中，可以从仓库中克隆，也可以创建一个名为 __ 的文件并复制其上的代码。__在 __ 文件中设置别名，__执行下面的命令使其生效，__一切就绪，现在你可以执行 __ 命令，自动将文件移动到”垃圾桶”，而不是永久删除它们。__测试一下，我们将删除一个名为 __ 的文件，命令行明确的提醒了 __。__也可以通过 __ 命令或 __ 进行验证。__或者我们可以通过文件管理器界面中查看相同的内容。__（LCTT 译注：原文此处混淆了部分 trash-cli 的内容，考虑到文章衔接和逻辑，此处略。）__要了解 __ 的其他选项，请查看帮助。__ ", "url": "http://blog.jobbole.com/113737/", "image_file_path": "full/d1b17b98748a74826464a08e6d30a4ee1b15b171.jpg", "pubtime": "2018/03/11"}
{"fav_num": 0, "url_object_id": "f7fd5491f869ff395a8d3670134dea28", "tags": "IT技术·开发者", "comment_num": 0, "title": "励志！海外开发者讲述用脚做游戏的研发经历", "praise_num": 0, "image_urls": ["http://jbcdn2.b0.upaiyun.com/2018/03/f4b90537c9da89d7b415ea699c9fe008.jpg"], "contents": "对于游戏开发者而言，失去双手对于职业和生活可能是灾难性的打击。__然而，业内却有一小部分人每天都要面临这样的问题，位于奥斯丁的开发者Rusty Moyher就是其中之一。五年前，他被诊断为重复性劳损（RSI），而作为一名写代码的游戏策划，这个病症几乎让他的职业生涯和对游戏的热情遭遇毁灭性打击。__图片来自网络，并非开发者本人__为了便于理解，这里我们复制了一段百度百科的介绍:重复使力伤害（repetitive strain injury，缩写RSI），或称重复性劳损、劳肌损伤、重复性动作的伤害，是指因长时间重复使用某组肌肉造成的损害。吉他、打字、在装配线工作、某些球类运动（棒球、网球、高尔夫球）都可能引致RSI，是常见的职业病，疼痛、肿胀、僵硬和易累等都是RSI的病征。不会在瞬间发生，是经年累月，不知不觉地缠上电脑使用者。如未经治疗，可能会对双手造成无可挽救的损害，一旦严重的伤害，双手将不再灵活。但到了这个时候，往往神经、肌肉和结缔组织，早已受到严重的损伤。__对于游戏开发者来说这个问题是很严重的，因为鼠标和键盘是最有效的工作和交流方式，但对于患有RSI疾病的人而言，这两个外设几乎形同虚设，所以使用电脑都是很大的问题。__然而，Rusty决定学习不用手的方式做游戏研发，他几乎用了一年半的时间学习与电脑互动的新方式，通过语音编程、眼部追踪和脚踏板的方式完成了游戏研发。上个月，他创作的新游戏《Dig Dog》正式登录PC、主机和手游平台。__本质来说，Moyher是可以使用手的，但RSI意味着连续几个小时使用键盘鼠标已经是不可能的，为了找回对游戏研发的热情，他必须使用新的方式与电脑互动。最开始的时候，他尝试了很多种非传统外设，但却没有一个能够满足需求。__Moyher说，“我尝试了各种辅助设备，但投入了大量资金之后发现这些并没有什么作用，比如立体键盘、和立体鼠标等等，我买过250美元一个的辊轮鼠标，用起来还可以，但我觉得人类的身体素质各异，所以你很难找到真正适合你用的”。__他的第一次突破是发现了一个可以用语音写代码的视频，这个视频是Travis Rudd在2013年发布的，后者也是一个患有RSI症状的程序员和开发者，视频中展示了Rudd自己研发的声音识别软件Dragon NaturallySpeaking，这样就可以通过语音指令写Python代码。__与Rudd联系之后，Moyher学习了Natlink与Dragonfly工具，这些可以让用户把定制化的关键短语作为触发器，如果你不太熟悉这个软件，那么我们进行简单的介绍，在默认情况下，它的主要工作就是把一个人的声音转化为文字，如果没有额外的工具和变成，那么使用Dragon写代码是非常消耗时间的工作。__通过配合Natlink与Dragonfly工具，Moyher可以直接使用语音指令，但这对他来说并没有那么容易适应。“我用了很长时间适应这种工具的使用方法，实际上在项目开始的一年半之前就已经在尝试了，当时我只是在研究这些工具，尝试适合我的方式”。__据Moyher透露，大多数的时间都用在了把输入方式简单化，这样他在工作的时候就不用担心一个失误导致所有工作都白费，“我看到过有些人使用这种语音写代码的案例，他们会设置中继设备，比如在虚拟机里运行Windows系统和Dragon软件，比如Parallels，而且他们使用这些与操作系统的外界声音进行交流”。__这让整个过程更加复杂，所以他决定进行简化，“我是直接使用Windows，所以就没有那么多的相关环节，这样错误的几率就会降低，“在简化之后，我用起来更为得心应手”。Moyher遇到的另一个问题就是他不能直接使用Rudd研发的Python指令，因为Moyher使用的集成研发环境（IDE）是Visual Studio和Xcode。他不仅要研发新的语音指令，由于这些环境使用鼠标的频率很高，所以他还要需要新的指令输入方式。__虽然Moyher尝试了大量不同的外设，但没有一个真正令他满意，直到体验了Natural Point的SmartNav 4，SmartNav的工作原理就是追踪与Moyher帽子上连接的反射器，由于灵敏度较高，他只需要很小幅度的转头就可以在屏幕上发出指令，然而他也表示，SmartNav 4也并不是100%理想。__“SmartNav 4是我在网上找到的，由于我知道自己的病情，只能尽可能少的用手，多休息，所以它成为了一个很好的鼠标替代工具，至少已经足够好用。但我认为它可以变得更好，软件版本很老，而且也是一个不那么注意细节的USB设备”。__用了这个设备之后，Moyher对它的要求更高了，“我从其他人那里得到了很多使用眼睛追踪的建议，这些事情实际上我以前就尝试过，所以决定深度挖掘这种方式”。__当然，找到不用手操作鼠标并不是唯一的问题，他还需要解决鼠标点击输入的问题，当然，这跟眼部追踪或者语音识别比起来就简单很多，“我是用脚点击的，所以这种设备用起来较为便宜，而且使用起来也很方便”。__游戏研发是辛苦的，但如果你面临Moyher这样的困难，那就更艰难了。《Dig Dog》最初是一个很简单的游戏，只是让一条狗在沙漠中行走，他非常喜欢平台游戏，但加入了挖掘玩法之后，这款游戏的玩法重心就发生了变化，而且项目最初的名字也不是Dig Dog。__“游戏名字并不是参考了《Dig Dug》，最初我只是想做一款让狗狗在沙漠中行走的游戏，一开始我很想做一款iOS平台游戏，这个游戏就是这么开始的。发现了挖掘玩法之后，游戏的主要玩法就变成了挖掘，曾几何时我给项目取的名字是Dig A Dog A Bone，但最后《Dig Dog》更利于传播”。__为了写代码，Moyher不仅要重新思考新的代码输入方式，还需要重新设计代码整体布局，在游戏研发过程中，他的输入方式也发生了很多变化。不过，游戏测试仍然需要他使用双手，“的确，这是一款平台游戏，游戏带给玩家的感觉是很重要的，你必须亲自体验和经历手柄操作，所以我有时候也避免不了”。__在编写《Dig Dog》代码的时候，Moyher克服了重重困难，他打算继续追逐游戏研发的梦想，疾病没有扼杀他对于游戏研发的热爱，他不仅继续编程，还坚持玩游戏，这样可以让游戏设计被更多人接受。__“这些方法是我在使用SmartNav 4的时候发现的，我最开始只是用鼠标和脚踏板玩游戏，随后我开始尝试其他回合制游戏，并且寻找不用手进行游戏操作的方式”。__虽然游戏速度是一方面的因素，Moyher表示一款游戏真正的难度在于，玩家需要同时处理很多东西，“我觉得回合制游戏比较适合，比如《RimWorld》用这种方法玩起来就很难，你需要点击太多的东西，鼠标的不精确让你很难操作这么多的单位”。__之所以提到Moyher的故事，主要是为了说明，只要你对于某些事情有热情，就能找到方法克服重重困难，或许，他在采访最后所说的话可以给业内所有同行共勉：我开始这个项目的时候，就已经有了足够多的工具，所以很确定整个游戏是能够做出来的，我只需要更有耐心就可以完成，但当时我甚至不知道能否做得到，虽然写代码很难，但我认为只要你想学，所有人都能学会。", "url": "http://blog.jobbole.com/113722/", "image_file_path": "full/6d8769da18e5fbec28cb5a2e5550323fe12e463a.jpg", "pubtime": "2018/03/08"}
{"fav_num": 4, "url_object_id": "20d0b326ed26dff7f3c5708bdf46c1a5", "tags": "IT技术·Linux", "comment_num": 0, "title": "Linux 启动过程分析", "praise_num": 0, "image_urls": ["http://jbcdn2.b0.upaiyun.com/2018/01/1b8322e1daff605d71fc81e724421f17.jpg"], "contents": "理解运转良好的系统对于处理不可避免的故障是最好的准备。__关于开源软件最古老的笑话是：“代码是自具文档化的self-documenting”。经验表明，阅读源代码就像听天气预报一样：明智的人依然出门会看看室外的天气。本文讲述了如何运用调试工具来观察和分析 Linux 系统的启动。分析一个功能正常的系统启动过程，有助于用户和开发人员应对不可避免的故障。__从某些方面看，启动过程非常简单。内核在单核上以单线程和同步状态启动，似乎可以理解。但内核本身是如何启动的呢？__ 和引导程序bootloader具有哪些功能？还有，为什么以太网端口上的 LED 灯是常亮的呢？__请继续阅读寻找答案。在 GitHub 上也提供了 __。__OFF 状态表示系统没有上电，没错吧？表面简单，其实不然。例如，如果系统启用了局域网唤醒机制（WOL），以太网指示灯将亮起。通过以下命令来检查是否是这种情况：__其中 <interface name>__ 是网络接口的名字，比如 __。（__ 可以在同名的 Linux 软件包中找到。）如果输出中的 __ 显示 __，则远程主机可以通过发送 __ 来启动系统。如果您无意远程唤醒系统，也不希望其他人这样做，请在系统 BIOS 菜单中将 WOL 关闭，或者用以下方式：__响应魔法数据包的处理器可能是网络接口的一部分，也可能是 __（BMC）。__BMC 不是唯一的在系统关闭时仍在监听的微控制器（MCU）。x86_64 系统还包含了用于远程管理系统的英特尔管理引擎（IME）软件套件。从服务器到笔记本电脑，各种各样的设备都包含了这项技术，它开启了如 KVM 远程控制和英特尔功能许可服务等 __。根据 __，__。坏消息是，要禁用 IME 很难。Trammell Hudson 发起了一个 __，它可以清除一些相对恶劣的 IME 组件，比如嵌入式 Web 服务器，但也可能会影响运行它的系统。__IME 固件和系统管理模式System Management Mode（SMM）软件是 __ 的，并运行在单独的平台控制器单元Platform Controller Hub上（LCTT 译注：即南桥芯片），而不是主 CPU 上。然后，SMM 启动位于主处理器上的通用可扩展固件接口Universal Extensible Firmware Interface（UEFI）软件，相关内容 __。Google 的 Coreboot 小组已经启动了一个雄心勃勃的 __（NERF）项目，其目的不仅是要取代 UEFI，还要取代早期的 Linux 用户空间组件，如 systemd。在我们等待这些新成果的同时，Linux 用户现在就可以从 Purism、System76 或 Dell 等处购买 __ 的笔记本电脑，另外 __ 还是值得期待的。__除了启动那些问题不断的间谍软件外，早期引导固件还有什么功能呢？引导程序的作用是为新上电的处理器提供通用操作系统（如 Linux）所需的资源。在开机时，不但没有虚拟内存，在控制器启动之前连 DRAM 也没有。然后，引导程序打开电源，并扫描总线和接口，以定位内核镜像和根文件系统的位置。U-Boot 和 GRUB 等常见的引导程序支持 USB、PCI 和 NFS 等接口，以及更多的嵌入式专用设备，如 NOR 闪存和 NAND 闪存。引导程序还与 __（TPM）等硬件安全设备进行交互，在启动最开始建立信任链。__包括树莓派、任天堂设备、汽车主板和 Chromebook 在内的系统都支持广泛使用的开源引导程序 __。它没有系统日志，当发生问题时，甚至没有任何控制台输出。为了便于调试，U-Boot 团队提供了一个沙盒，可以在构建主机甚至是夜间的持续集成（CI）系统上测试补丁程序。如果系统上安装了 Git 和 GNU Compiler Collection（GCC）等通用的开发工具，使用 U-Boot 沙盒会相对简单：__在 x86_64 上运行 U-Boot，可以测试一些棘手的功能，如 __ 的重新分区、基于 TPM 的密钥操作以及 USB 设备热插拔等。U-Boot 沙盒甚至可以在 GDB 调试器下单步执行。使用沙盒进行开发的速度比将引导程序刷新到电路板上的测试快 10 倍，并且可以使用 __ 恢复一个“变砖”的沙盒。__引导程序完成任务后将跳转到已加载到主内存中的内核代码，并开始执行，传递用户指定的任何命令行选项。内核是什么样的程序呢？用命令 __ 可以看到它是一个 “bzImage”，意思是一个大的压缩的镜像。Linux 源代码树包含了一个可以解压缩这个文件的工具—— __：__内核是一个 __（ELF）的二进制文件，就像 Linux 的用户空间程序一样。这意味着我们可以使用 __ 包中的命令，如 __ 来检查它。比较一下输出，例如：__这两个二进制文件中的段内容大致相同。__所以内核必须像其他的 Linux ELF 文件一样启动，但用户空间程序是如何启动的呢？在 __ 函数中？并不确切。__在 __ 函数运行之前，程序需要一个执行上下文，包括堆栈内存以及 __、__ 和 __ 的文件描述符。用户空间程序从标准库（多数 Linux 系统在用 “glibc”）中获取这些资源。参照以下输出：__ELF 二进制文件有一个解释器，就像 Bash 和 Python 脚本一样，但是解释器不需要像脚本那样用 __ 指定，因为 ELF 是 Linux 的原生格式。ELF 解释器通过调用 __ 函数来用所需资源 __，这个函数可以从 glibc 源代码包中找到，可以 __。内核显然没有解释器，必须自我配置，这是怎么做到的呢？__用 GDB 检查内核的启动给出了答案。首先安装内核的调试软件包，内核中包含一个未剥离的unstripped vmlinux，例如 __，或者从源代码编译和安装你自己的内核，可以参照 __ 中的指令。__ 后加 __ 可显示 ELF 段 __。在 __ 中用 __ 列出程序执行的开头，其中 __ 是 __ 的十六进制开头。用 GDB 可以看到 x86_64 内核从内核文件 __ 开始启动，在这个文件中我们找到了汇编函数 __，以及一段明确的代码显示在调用 __ 函数之前创建了堆栈并解压了 zImage。ARM 32 位内核也有类似的文件 __。__ 不针对特定的体系结构，所以这个函数驻留在内核的 __ 中。__ 可以说是 Linux 真正的 __ 函数。__在引导时，内核需要硬件信息，不仅仅是已编译过的处理器类型。代码中的指令通过单独存储的配置数据进行扩充。有两种主要的数据存储方法：__ 和 __。内核通过读取这些文件了解每次启动时需要运行的硬件。__对于嵌入式设备，设备树是已安装硬件的清单。设备树只是一个与内核源代码同时编译的文件，通常与 __ 一样位于 __ 目录中。要查看 ARM 设备上的设备树的内容，只需对名称与 __ 匹配的文件执行 __ 包中的 __ 命令即可，这里 __ 是指设备树二进制文件device-tree binary。显然，只需编辑构成它的类 JSON 的文件并重新运行随内核源代码提供的特殊 __ 编译器即可修改设备树。虽然设备树是一个静态文件，其文件路径通常由命令行引导程序传递给内核，但近年来增加了一个 __ 的功能，内核在启动后可以动态加载热插拔的附加设备。__x86 系列和许多企业级的 ARM64 设备使用 __ 机制。与设备树不同的是，ACPI 信息存储在内核在启动时通过访问板载 ROM 而创建的 __ 虚拟文件系统中。读取 ACPI 表的简单方法是使用 __ 包中的 __ 命令。例如：__是的，你的 Linux 系统已经准备好用于 Windows 2001 了，你要考虑安装吗？与设备树不同，ACPI 具有方法和数据，而设备树更多地是一种硬件描述语言。ACPI 方法在启动后仍处于活动状态。例如，运行 __ 命令（在 __ 包中），然后打开和关闭笔记本机盖会发现 ACPI 功能一直在运行。暂时地和动态地 __ 是可能的，而永久地改变它需要在引导时与 BIOS 菜单交互或刷新 ROM。如果你遇到那么多麻烦，也许你应该 __，这是开源固件的替代品。__ 中的代码竟然是可读的，而且有趣的是，它仍然在使用 1991 – 1992 年的 Linus Torvalds 的原始版权。在一个刚启动的系统上运行 __，其输出主要来源于此文件。第一个 CPU 注册到系统中，全局数据结构被初始化，并且调度程序、中断处理程序（IRQ）、定时器和控制台按照严格的顺序逐一启动。在 __ 函数运行之前，所有的时间戳都是零。内核初始化的这部分是同步的，也就是说执行只发生在一个线程中，在最后一个完成并返回之前，没有任何函数会被执行。因此，即使在两个系统之间，__ 的输出也是完全可重复的，只要它们具有相同的设备树或 ACPI 表。Linux 的行为就像在 MCU 上运行的 RTOS（实时操作系统）一样，如 QNX 或 VxWorks。这种情况持续存在于函数 __ 中，该函数在终止时由 __ 调用。__函数 __ 产生了一个新进程以运行 __，并调用了 __。用户可以通过将 __ 附加到内核命令行来监控 __，这样每运行一次 __ 函数就会产生 一个 __ 条目。__ 会历经七个连续的级别：early、core、postcore、arch、subsys、fs、device 和 late。__ 最为用户可见的部分是所有处理器外围设备的探测和设置：总线、网络、存储和显示器等等，同时加载其内核模块。__ 也会在引导处理器上产生第二个线程，它首先运行 __，然后等待调度器分配工作。__ 也可以 __。在较新的内核中，如果 __ 的输出中出现 “Bringing up secondary CPUs…” 等字样，系统便使用了 SMP。SMP 通过“热插拔” CPU 来进行，这意味着它用状态机来管理其生命周期，这种状态机在概念上类似于热插拔的 U 盘一样。内核的电源管理系统经常会使某个核core离线，然后根据需要将其唤醒，以便在不忙的机器上反复调用同一段的 CPU 热插拔代码。观察电源管理系统调用 CPU 热插拔代码的 __ 称为 __。__请注意，__ 中的代码在 __ 运行时几乎已执行完毕：引导处理器已经完成了大部分一次性初始化操作，其它核无需重复。尽管如此，跨 CPU 的线程仍然要在每个核上生成，以管理每个核的中断（IRQ）、工作队列、定时器和电源事件。例如，通过 __ 命令可以查看服务每个 CPU 上的线程的 softirqs 和 workqueues。__其中，PSR 字段代表“处理器processor”。每个核还必须拥有自己的定时器和 __ 热插拔处理程序。__那么用户空间是如何启动的呢？在最后，__ 寻找可以代表它执行 __ 进程的 __。如果没有找到，内核直接执行 __ 本身。那么为什么需要 __ 呢？__除了设备树之外，在启动时可以提供给内核的另一个文件路径是 __ 的路径。__ 通常位于 __ 目录中，与 x86 系统中的 bzImage 文件 vmlinuz 一样，或是与 ARM 系统中的 uImage 和设备树相同。用 __ 软件包中的 __ 工具可以列出 __ 的内容。发行版的 __ 方案包含了最小化的 __、__ 和 __ 目录以及内核模块，还有 __ 中的一些文件。所有这些看起来都很熟悉，因为 __ 大致上是一个简单的最小化 Linux 根文件系统。看似相似，其实不然，因为位于虚拟内存盘中的 __ 和 __ 目录下的所有可执行文件几乎都是指向 __ 的符号链接，由此导致 __ 和 __ 目录比 glibc 的小 10 倍。__如果要做的只是加载一些模块，然后在普通的根文件系统上启动 __，为什么还要创建一个 __ 呢？想想一个加密的根文件系统，解密可能依赖于加载一个位于根文件系统 __ 的内核模块，当然还有 __ 中的。加密模块可能被静态地编译到内核中，而不是从文件加载，但有多种原因不希望这样做。例如，用模块静态编译内核可能会使其太大而不能适应存储空间，或者静态编译可能会违反软件许可条款。不出所料，存储、网络和人类输入设备（HID）驱动程序也可能存在于 __ 中。__ 基本上包含了任何挂载根文件系统所必需的非内核代码。__ 也是用户存放 __ 表代码的地方。__ 对测试文件系统和数据存储设备也很有用。将这些测试工具存放在 __ 中，并从内存中运行测试，而不是从被测对象中运行。__最后，当 __ 开始运行时，系统就启动啦！由于第二个处理器现在在运行，机器已经成为我们所熟知和喜爱的异步、可抢占、不可预测和高性能的生物。的确，__ 很容易显示用户空间的 __ 进程已不在引导处理器上运行了。__Linux 引导过程听起来或许令人生畏，即使是简单嵌入式设备上的软件数量也是如此。但换个角度来看，启动过程相当简单，因为启动中没有抢占、RCU 和竞争条件等扑朔迷离的复杂功能。只关注内核和 PID 1 会忽略了引导程序和辅助处理器为运行内核执行的大量准备工作。虽然内核在 Linux 程序中是独一无二的，但通过一些检查 ELF 文件的工具也可以了解其结构。学习一个正常的启动过程，可以帮助运维人员处理启动的故障。__要了解更多信息，请参阅 Alison Chaiken 的演讲——__，已于 1 月 22 日至 26 日在悉尼举行。参见 __。__感谢 __ 的提议和指正。__ ", "url": "http://blog.jobbole.com/113768/", "image_file_path": "full/14452eea6b79bce0219227f298ad827f2ba7112d.jpg", "pubtime": "2018/03/13"}
{"fav_num": 1, "url_object_id": "7cb32f69be9fc1f56a8f1a54e4cf6b00", "tags": "IT技术·搜索·数据库", "comment_num": 0, "title": "索引表和 ES 的一点点思考", "praise_num": 0, "image_urls": ["http://jbcdn2.b0.upaiyun.com/2011/11/go-out-of-the-three-errors-of-the-seo.jpg"], "contents": "在电商项目中，物理库存系统是个极其重要的系统，订单支付后，就会开始来占用物理库存。一般情况下，库存系统都是要分库的，因为主要的操作是写操作，例如占用/释放/取消等写操作。使用分库可以降低数据库写的压力。尽管写操作为主，但是读操作也是有的。__比如说，库存占用的时候，得先查询是否有库存，而这个查询操作并不都会带上分库因子(用于路由到具体的某个数据库)，而是一些比较宽松的查询条件，这些查询条件对应的数据可能分布在不同的数据库上。这个时候为了查询的方便，会构建一个索引表。这个索引表是__，不会再分库了的。__索引表的设计也分不同情况，大体可以分三种。__\n1、查询字段+数据库主键__把查询字段放到索引表，还需要把对应的数据库主键ID也放置进去。当查询请求到来时，根据查询条件找出对应的数据主键，再根据数据主键路由到对应的存有完整业务数据的数据分库上。这种方案呢。索引表占用空间小，可以支撑很久。但是要找出业务数据，还是需要路由到分库上。另外，如果要把索引表的数据存储到ES搜索引擎上的话，这种方式就不行了。因为索引表中没有外部系统要的业务数据。所以当时的库存系统没有使用这种索引表设计方案。__2、查询字段+数据库主键+需要展示的业务字段__这种方案呢。当请求到来的时候，直接查询索引表即可。无需根据主键路由到分库了。同时如果要结合ES的话。可以直接把索引表的数据弄到ES上即可。后续直接让ES暴露查询接口即可。目前我在唯品会参与的物理库存项目中，是使用这种方式的。但是这个方案也有个缺点。就是索引表的体积比较大，后续数据量一大的话，也是个问题。能不能优化一下呢？__3、索引表拆分__上面说到的第二种方案，索引表的膨胀可能很快，可以考虑将索引表拆分。比如说：索引表只是保存查询条件和主键，而需要展示给外部系统的数据，另外存储在单独的表上。比如叫index_detail表。这个表拥有索引表的主键。这样的话，当查询请求到来的时候，先从索引表查询到主键，再根据主键从index_detail表中查询出数据。当然这样做的话。ES的数据来源就变成多张表了，不过这是可以接受的。__一般来说，构建索引数据是使用单独一个应用来做的。比如叫data-index域。这个域会从消息队列中读取消息，用于构建索引数据。当业务数据发生变化后，生产者发送MQ消息到队列上。__\n这里的消息设计也分两种情况。一种是消息只是带有数据主键和操作类型(ADD/Update/DELETE),消费者拿到主键后再去DB获取完整的数据并插入到索引表中。另一种方案呢，是消息包含了大部分需要的字段，消费者拿到消息后直接把数据插入到索引表中。这两种消息设计，我在实际项目中都有用过。__这种方案呢就比较粗暴，直接配置一个索引表库的数据源，当业务数据发生变化时，使用Mybatis或者JDBC把数据更新到索引表中。一般不建议这么做，一来构建索引数据的逻辑跟数据的CRUD操作融合在一起了。二来，操作其他数据库的数据，要么通过接口的方式，要么由单独的域来做。建议还是使用MQ的方式来构建索引数据。__像在唯品会这边，自研了一个叫VDP的组件，使用storm job去监听索引表数据的变化，一旦有变化，就把数据同步到队列中，ES直接从队列中获取数据，并存储到ES上。__\n这种方案的好处是，我们无需写任何代码，数据自动可以同步到ES上。__如果公司内部没有开发VDP这样的组件，可以通过发送MQ消息的方式来将索引表的数据同步数据到ES上。__另外一种方案是，让ES暴露CUD接口，用于同步索引表数据。但是这样就跟ES耦合在一块了。不太推荐这么做。__1、ES不支持Group By这样的操作，所以在构建索引表的时候，可以事先计算好Group By的一些统计数据，并存储到索引表中；__\n2、一些后台应用中，如果数据库表的数量已经很大，好几个亿了，并且查询的SQL还非常变态，用数据库已经无法支持了，那么可以使用ES，查询速度快，也支持一些统计操作；__\n3、使用ES输出数据时，也有个坑。经常会拿到脏数据的。例如当数据发送变化后，构建索引数据并把索引数据同步到ES上是需要时间的，但是我们后台通常有将数据下架的操作，下架的操作操作完后，再次点击查询按钮，可能还是看到脏数据，因为数据同步到ES上没那么快。现在我还没想到很好的办法来解决这个问题。欢迎网友提些建议。__\n                        __\n            \n                    ", "url": "http://blog.jobbole.com/113726/", "image_file_path": "full/8cd9b25acfe438d20acd37accc39f6be8b8924dc.jpg", "pubtime": "2018/03/08"}
{"fav_num": 2, "url_object_id": "b49b820d1a88139adbc0e923d2f824f6", "tags": "IT技术·Linux", "comment_num": 0, "title": "Linux 跟踪器之选", "praise_num": 0, "image_urls": ["http://jbcdn2.b0.upaiyun.com/2018/01/1b8322e1daff605d71fc81e724421f17.jpg"], "contents": "Linux 跟踪很神奇！__跟踪器tracer是一个高级的性能分析和调试工具，如果你使用过 __ 或者 __，你不应该被它吓到 … 你使用的就是跟踪器。系统跟踪器能让你看到很多的东西，而不仅是系统调用或者数据包，因为常见的跟踪器都可以跟踪内核或者应用程序的任何东西。__有大量的 Linux 跟踪器可供你选择。由于它们中的每个都有一个官方的（或者非官方的）的吉祥物，我们有足够多的选择给孩子们展示。__你喜欢使用哪一个呢？__我从两类读者的角度来回答这个问题：大多数人和性能/内核工程师。当然，随着时间的推移，这也可能会发生变化，因此，我需要及时去更新本文内容，或许是每年一次，或者更频繁。（LCTT 译注：本文最后更新于 2015 年）__大多数人（开发者、系统管理员、运维人员、网络可靠性工程师（SRE）…）是不需要去学习系统跟踪器的底层细节的。以下是你需要去了解和做的事情：__可以使用 perf_events 进行 CPU 剖析profiling。它可以用一个 __ 来形象地表示。比如：__Linux 的 perf_events（即 __，后者是它的命令）是官方为 Linux 用户准备的跟踪器/分析器。它位于内核源码中，并且维护的非常好（而且现在它的功能还在快速变强）。它一般是通过 linux-tools-common 这个包来添加的。__ 可以做的事情很多，但是，如果我只能建议你学习其中的一个功能的话，那就是 CPU 剖析。虽然从技术角度来说，这并不是事件“跟踪”，而是采样sampling。最难的部分是获得完整的栈和符号，这部分在我的 __ 中针对 Java 和 Node.js 讨论过。__正如一位朋友所说的：“你不需要知道 X 光机是如何工作的，但你需要明白的是，如果你吞下了一个硬币，X 光机是你的一个选择！”你需要知道使用跟踪器能够做什么，因此，如果你在业务上确实需要它，你可以以后再去学习它，或者请会使用它的人来做。__简单地说：几乎任何事情都可以通过跟踪来了解它。内部文件系统、TCP/IP 处理过程、设备驱动、应用程序内部情况。阅读我在 lwn.net 上的 __ 的文章，也可以去浏览 __，那里有一些跟踪（和剖析）能力的示例。__如果你要购买一个性能分析工具（有许多公司销售这类产品），并要求支持 Linux 跟踪。想要一个直观的“点击”界面去探查内核的内部，以及包含一个在不同堆栈位置的延迟热力图。就像我在 __ 中描述的那样。__我创建并开源了我自己的一些前端工具，虽然它是基于 CLI 的（不是图形界面的）。这样可以使其它人使用跟踪器更快更容易。比如，我的 __，跟踪新进程是这样的：__在 Netflix 公司，我正在开发 __，它是一个实例分析工具，实际上它也是一个 Linux 跟踪器的前端。__一般来说，我们的工作都非常难，因为大多数人或许要求我们去搞清楚如何去跟踪某个事件，以及因此需要选择使用哪个跟踪器。为完全理解一个跟踪器，你通常需要花至少一百多个小时去使用它。理解所有的 Linux 跟踪器并能在它们之间做出正确的选择是件很难的事情。（我或许是唯一接近完成这件事的人）__在这里我建议选择如下，要么：__A）选择一个全能的跟踪器，并以它为标准。这需要在一个测试环境中花大量的时间来搞清楚它的细微差别和安全性。我现在的建议是 SystemTap 的最新版本（例如，从 __ 构建）。我知道有的公司选择的是 LTTng ，尽管它并不是很强大（但是它很安全），但他们也用的很好。如果在 __ 中添加了跟踪点或者是 kprobes，它也是另外的一个候选者。__B）按我的 __ 的流程图。这意味着尽可能使用 ftrace 或者 perf_events，eBPF 已经集成到内核中了，然后用其它的跟踪器，如 SystemTap/LTTng 作为对 eBPF 的补充。我目前在 Netflix 的工作中就是这么做的。__以下是我对各个跟踪器的评价：__我爱 __，它是内核黑客最好的朋友。它被构建进内核中，它能够利用跟踪点、kprobes、以及 uprobes，以提供一些功能：使用可选的过滤器和参数进行事件跟踪；事件计数和计时，内核概览；函数流步进function-flow walking。关于它的示例可以查看内核源代码树中的 __。它通过 __ 来管理，是面向单一的 root 用户的（虽然你可以使用缓冲实例以让其支持多用户），它的界面有时很繁琐，但是它比较容易调校hackable，并且有个前端：ftrace 的主要创建者 Steven Rostedt 设计了一个 trace-cmd，而且我也创建了 perf-tools 集合。我最诟病的就是它不是可编程的programmable，因此，举个例子说，你不能保存和获取时间戳、计算延迟，以及将其保存为直方图。你需要转储事件到用户级以便于进行后期处理，这需要花费一些成本。它也许可以通过 eBPF 实现可编程。__ 是 Linux 用户的主要跟踪工具，它的源代码位于 Linux 内核中，一般是通过 linux-tools-common 包来添加的。它又称为 __，后者指的是它的前端，它相当高效（动态缓存），一般用于跟踪并转储到一个文件中（perf.data），然后可以在之后进行后期处理。它可以做大部分 ftrace 能做的事情。它不能进行函数流步进，并且不太容易调校（而它的安全/错误检查做的更好一些）。但它可以做剖析（采样）、CPU 性能计数、用户级的栈转换、以及使用本地变量利用调试信息debuginfo进行行级跟踪line tracing。它也支持多个并发用户。与 ftrace 一样，它也不是内核可编程的，除非 eBPF 支持（补丁已经在计划中）。如果只学习一个跟踪器，我建议大家去学习 perf，它可以解决大量的问题，并且它也相当安全。__扩展的伯克利包过滤器extended Berkeley Packet Filter（eBPF）是一个内核内in-kernel的虚拟机，可以在事件上运行程序，它非常高效（JIT）。它可能最终为 ftrace 和 perf_events 提供内核内编程in-kernel programming，并可以去增强其它跟踪器。它现在是由 Alexei Starovoitov 开发的，还没有实现完全的整合，但是对于一些令人印象深刻的工具，有些内核版本（比如，4.1）已经支持了：比如，块设备 I/O 的延迟热力图latency heat map。更多参考资料，请查阅 Alexei 的 __，和它的 __。__ 是一个非常强大的跟踪器。它可以做任何事情：剖析、跟踪点、kprobes、uprobes（它就来自 SystemTap）、USDT、内核内编程等等。它将程序编译成内核模块并加载它们 —— 这是一种很难保证安全的方法。它开发是在内核代码树之外进行的，并且在过去出现过很多问题（内核崩溃或冻结）。许多并不是 SystemTap 的过错 —— 它通常是首次对内核使用某些跟踪功能，并率先遇到 bug。最新版本的 SystemTap 是非常好的（你需要从它的源代码编译），但是，许多人仍然没有从早期版本的问题阴影中走出来。如果你想去使用它，花一些时间去测试环境，然后，在 irc.freenode.net 的 #systemtap 频道与开发者进行讨论。（Netflix 有一个容错架构，我们使用了 SystemTap，但是我们或许比起你来说，更少担心它的安全性）我最诟病的事情是，它似乎假设你有办法得到内核调试信息，而我并没有这些信息。没有它我实际上可以做很多事情，但是缺少相关的文档和示例（我现在自己开始帮着做这些了）。__ 对事件收集进行了优化，性能要好于其它的跟踪器，也支持许多的事件类型，包括 USDT。它的开发是在内核代码树之外进行的。它的核心部分非常简单：通过一个很小的固定指令集写入事件到跟踪缓冲区。这样让它既安全又快速。缺点是做内核内编程不太容易。我觉得那不是个大问题，由于它优化的很好，可以充分的扩展，尽管需要后期处理。它也探索了一种不同的分析技术。很多的“黑匣子”记录了所有感兴趣的事件，以便可以在 GUI 中以后分析它。我担心该记录会错失之前没有预料的事件，我真的需要花一些时间去看看它在实践中是如何工作的。这个跟踪器上我花的时间最少（没有特别的原因）。__ 是一个很有前途的跟踪器，它在内核中使用了一个 lua 虚拟机，不需要调试信息和在嵌入时设备上可以工作的很好。这使得它进入了人们的视野，在某个时候似乎要成为 Linux 上最好的跟踪器。然而，由于 eBPF 开始集成到了内核，而 ktap 的集成工作被推迟了，直到它能够使用 eBPF 而不是它自己的虚拟机。由于 eBPF 在几个月过去之后仍然在集成过程中，ktap 的开发者已经等待了很长的时间。我希望在今年的晚些时间它能够重启开发。__ 主要由一个人（Paul Fox）利用业务时间将 Sun DTrace 移植到 Linux 中的。它令人印象深刻，一些供应器provider可以工作，还不是很完美，它最多应该算是实验性的工具（不安全）。我认为对于许可证的担心，使人们对它保持谨慎：它可能永远也进入不了 Linux 内核，因为 Sun 是基于 CDDL 许可证发布的 DTrace；Paul 的方法是将它作为一个插件。我非常希望看到 Linux 上的 DTrace，并且希望这个项目能够完成，我想我加入 Netflix 时将花一些时间来帮它完成。但是，我一直在使用内置的跟踪器 ftrace 和 perf_events。__ 是将 DTrace 移植到 Linux （尤其是 Oracle Linux）的重大努力。过去这些年的许多发布版本都一直稳定的进步，开发者甚至谈到了改善 DTrace 测试套件，这显示出这个项目很有前途。许多有用的功能已经完成：系统调用、剖析、sdt、proc、sched、以及 USDT。我一直在等待着 fbt（函数边界跟踪，对内核的动态跟踪），它将成为 Linux 内核上非常强大的功能。它最终能否成功取决于能否吸引足够多的人去使用 Oracle Linux（并为支持付费）。另一个羁绊是它并非完全开源的：内核组件是开源的，但用户级代码我没有看到。__ 是一个很新的跟踪器，它可以使用类似 __ 的语法来处理系统调用syscall事件，并用 lua 做后期处理。它也是令人印象深刻的，并且很高兴能看到在系统跟踪领域的创新。它的局限性是，它的系统调用只能是在当时，并且，它转储所有事件到用户级进行后期处理。你可以使用系统调用来做许多事情，虽然我希望能看到它去支持跟踪点、kprobes、以及 uprobes。我也希望看到它支持 eBPF 以查看内核内概览。sysdig 的开发者现在正在增加对容器的支持。可以关注它的进一步发展。__我自己的工作中使用到的跟踪器包括：__不好意思，没有更多的跟踪器了！ … 如果你想知道为什么 Linux 中的跟踪器不止一个，或者关于 DTrace 的内容，在我的 __ 的演讲中有答案，从 __ 开始。__感谢 __ 的编辑，以及跟踪小马的创建（General Zoi 是小马的创建者）。__ ", "url": "http://blog.jobbole.com/113735/", "image_file_path": "full/14452eea6b79bce0219227f298ad827f2ba7112d.jpg", "pubtime": "2018/03/10"}
{"fav_num": 4, "url_object_id": "2796ee392f681a8f36e227ce37a3b069", "tags": "开发·编程语言", "comment_num": 0, "title": "邪恶的编程咒语", "praise_num": 0, "image_urls": ["http://wx3.sinaimg.cn/large/7cc829d3gy1fo80ho6bhuj20fu09twfy.jpg"], "contents": "自从我看了 Gary Bernhardt 备受推崇的一个视频 __，就惊异于特定编程语言的怪异行为。相较于其他编程语言来说，某些编程语言的行为更出乎意料。例如，有__是针对 Java 的边缘案例和古怪情况。同样，差不多只要 200 美元你就可以阅读 __了。__下面是我最喜欢的、惊奇的、滑稽的并仍然有效的咒语集合。一般来讲，利用这些古怪的行为被视为__，因为代码不应该出乎意料。值得庆幸的是，如果你尝试以下大多数蠢事，有很多代码校检工具（linters）已经准备好嘲笑你了。说了这么多，知识就是力量，那就开始吧。__谢天谢地，这在 Python 3 中会导致 __，因为__。它仍远没有 C++ 的那个恶作剧那么邪恶，把 __ 悄悄写进同事的开发机器的标准头文件中。__对 Java 新手程序员来说，__ 的语义往往使人困惑。甚至在微不足道的情境下，这个操作符的前后矛盾也会使情况变得复杂，即使性能效益是值得的。__JVM 会对区间 [-128, 127] 内的值使用相同的引用。更奇怪的是，Python 中也有同样的行为。__目前为止，还没有特别出乎意料的。__似乎 python 解释器使用相同例子的下限是……-5。区间 [-5, 256] 内的整数有同样的 ID。不知怎地，这变得更奇怪了。__似乎使用解构赋值改变了这里的规则。我不确定为什么是这样。事实上，我在 __来试着理解它。我的猜测是，一个列表中的重复值指向同一个对象，用以节省内存。__颠倒的下标符号，会使所有开发者都头疼。__这行得通的原因是，__ 确实只是 __ 的语法糖。由于加法的交换性，我们可以交换数组和索引，并得到同样的结果。__ 操作符第一次被看到时，似乎是句法错误。在你意识到它可编译时，它看起来像未被记载的语言特性。幸运的是，两者都不是。__ “操作符”实际上是两个操作符，在这个背景下解析为__。众所周知，大量使用会导致困惑，这完全是邪恶的。__ 操作符是一个编译时操作符，这给予了它有趣的属性。__由于 __ 操作符的例子是对编译时进行评估的，__不会运行。另一件趣事是，研究表明 __ 是最普遍的没有被 push 的代码。__ 一直在用“__ __ __ __”表情包取乐。令人震惊的是，有大量编程语言使用从 1 开始的数组索引。可以在__找到更全面的清单。__… and only Ruby. *__在 Ruby 中是这样。*__* edit: It was pointed out on __ that this is true for Lua, Lisp, and Erlang as well.__* 修订：Reddit 上有人指出，这在 Lua、Lisp 和 Erlang 中也成立。__Trigraph, Digraphs, and Tokens in C__由于历史原因，C 语言中的非字母符号有替代品。__有些外国设备，例如 IBM 3270，在 C/C++ 中不提供某些常用符号，所以提供了 digraph、trigraph 和 token 来避免排斥特定字符集。", "url": "http://blog.jobbole.com/113631/", "image_file_path": "full/280c8276f25da11c38fa166860dc2754091de28f.jpg", "pubtime": "2018/03/12"}
{"fav_num": 2, "url_object_id": "aa94da9060b646e6772ebf4ad4c5ffe7", "tags": "业界·开源", "comment_num": 0, "title": "开源作者遭受小白的 9 种伤害", "praise_num": 0, "image_urls": ["http://jbcdn2.b0.upaiyun.com/2017/09/f1a3d556b79a7fae23ad3ecc6f972164.jpg"], "contents": "我是Beetl和BeetlSQL开源的作者，这俩类技术实现难度较大，前者是属于语言实现类开源，后者则是全功能ORM实现。但是这俩个开源使用门槛又低，能遇到各种各样的小白用户。我帮助小白解决了非常多技术问题，但也遭遇过小白给予的困扰。我总结了一下9种小白对开源作者造成的有意无意的伤害，并且按照严重程度分为3个级别__这种行为的小白从来没有察觉到提问是一门学科，没有研究如何提问，也没有观摩过别人的提问为何能得到专家的仔细回答。他总觉得，专家就在身边，专家有足够的时间帮助自己。他通常提问方式是__这类小白并不知道，开源作者都很忙，如果他空闲了恰好看到你的提问，但你没有科学提问，他几乎不会跟你去互动接下来你希望的事情。这种无意义的叨扰开源作者，挺让人心烦的。__这种行为小白是最为常见的小白，遇到问题都是以Baidu为工具来解决。小白需要清楚几点关于搜索引擎不能做到的地方__靠搜索引擎来解决问题的人，都会技术积累不牢固，较好的办法是以官网手册为中心，结合官网论坛，或者oschina这样专门的技术社区，结合源代码和搜索引擎来找到解决办法。对于小白来说，大部分问题都能从官网文档中找到答案。但小白却没有时间去研究官官网文档。以我经验，越是厉害的人越对官网文档重视，越要花时间去通读官网手册，官网的其他技术资料。 越是小白呢，因为忙就不详细了解官网文档，结果知识不牢固，会导致后面越来越忙（因为会一直解决跟本不是问题的问题），陷入恶心循环__我在我的SpringBoot-Plus开源中，安装说明有14行，有5行且标准了重点，都提到要用JDK8和打开Parameter参数，并详细说明了如果系统启动时报报错，应该就是paramter参数没有打开（我同时也链接了如何打开JDK8 paramter参数的文章),结果还是有10几位小白告诉我系统起不来，并附上了我在安装说明里提到过的相同错误。__这类小白老是问一下显而易见的问题，对开源作者和其他初级用户造成了困惑__这类小白对开源作者造成了常规性的伤害最多。有时候我都怀疑他们并不是不会，而是懒，以为开源作者就是他身边的老师，或者身边的同事 ，比如他们经常提一些明显能自己解决的问题，比如__这类小白的问题，如果你真有空回答，还并不好回答，这类小白的问题通常都需要大篇幅的解答其疑问，因为问的实在太基础了__这类小白有一定技术能力，但靠自己没有解决问题，因此在和开源作者交流过程中过于注重自己的情感体验了，比如__还比如经常有小白辛苦工作到晚上11点，然后qq群提问__其实大家不愿帮助，可能是因为都睡觉了，或者没有精力再深夜去帮你解决问题，但你宣泄了个人情感，估计第二天也不会得到社区任何帮助__这类小白是最让人开源作者头疼的，因为他们在寻求帮助的时候，不知道自己需要向开源作者提供什么样的信息。甚至有时候故意只将自己写正确的部分展示出来，来取得开源作者的认同。但这无法解决问题__最常见的是只贴出自己的代码，但并没有贴出错误提示。其实错误提示更能帮助开源作者解决问题，甚至不需要贴出你的代码都行。 有些人贴出了错误提示，比如异常栈，但并没有完整的贴出异常栈，有些人贴出了代码，但并没有把IDE的代码行也跟图粘贴出来，这导致无法交流__比如这个贴图，很难给开源作者提供详细的线索，真正的线索应该在下面未贴出的异常栈里__这个贴图则没有包含代码行数，会出现交流困难 __较好的方式是这个图__这类小白会非常浪费开源作者的时间，所以我认为是二级伤害。__我经常说一句话，你若仔细提问，我便详细回答。通常，对于社区提问附带多张图片的小白，非常受我欢迎__有些小白经过思考和探索后，提出了错误的问题。比如__。这类提问能错误引导问题解答者。正确的姿势应该是完整的说出自己的期望和自己的过程以及最后的现象。然后可以提出自己认为的解答方向来辅助开源作者帮你解决问题__开源作者回答的思路很多，背景信息对开源作者回答问题有很大帮助。比如，你是个新手，那么SpringBoot-Plus没有启动，可能是你没有安装Maven或者JDK，如果你是个SpringBoot有经验者，曾经用SpringBoot在好几个项目里，那么启动失败可能真的意味这有环境不兼容，甚至是开源Bug__小白提问的时候花几句介绍一下自己是非常有必要的，比如__这样的提问，比小白一上来就问如何实现AOP好很多，前者能帮助开源作者知道解答的范围从而精确解答，节省了开源作者的时间，也节省了小白时间__开源作者都是出于兴趣在业余时间完成开源，也是抽空帮助解答问题，因此如果开源作者不回答问题，或者简洁回答，这都是开源作者的常态行为。但有些小白却认为受到了冒犯从而转为攻击开源作者。__我就遭受过俩个人类似的攻击，他们嫌我怠慢他们，或者是言语上让他们难堪，就转而在社区攻击我，比如，用小号再次潜入群里，故意激怒我踢走他，然后他在oschina上发帖子说《beetl作者闲大赋为什么如此自负和目中无人》，并截图为证。这个帖子在oschina首页因为热门而存在了一个月时间__还有人因为我的怠慢而在社区收集我的各种黑证据，比如有一次看到并发里的内存模型，我就在社区提问（其实当时我已经了解了），意图是想让大家讨论一下技术，结果又有人马上把这个截图发到社区，然后说《闲大赋连并发都不懂》__这个也许是特列，但我碰上了，这位小白是某大互联网公司的技术人员，在社区里不可一世，甚至开始教育其他人的品德。作为一个年轻人，非常猖狂。我后来驱逐他出社区后，没想到的是，网站立刻不能访问，一直遭受暴力破解，而且他还通过小号在社区直播破坏过程。第二天，ibeetl.com 真的不能访问，整个社区被黑，数据被清空，积累了3年的技术问答全不不复存在。__后来在社区其他人员帮助写，用SpringBoot+Beetl+BeetlSQL重写了一个java论坛，甚至开源了这个项目，因祸得福吧。远离了恶人，结交了真朋友__作为开源作者，提供了自己的想法和实践出来的作品，难得可贵，如果有好的小白，那么开源产品会更加完美。如果遭遇到上面我列举出来的各种小白，那就是开源作者的不幸，我觉得这个一直是常态，遇上几个特别优秀的小白，又会碰上几个对开源作者造成各种级别伤害的小白。希望小白们看了这个博客，能减少自己对开源作者造成的困扰和伤害，同时提高自己的技术水平", "url": "http://blog.jobbole.com/113728/", "image_file_path": "full/70c7b887c37d9154dc2b5636ed919464c716d375.jpg", "pubtime": "2018/03/09"}
{"fav_num": 1, "url_object_id": "a6f0ef6debff996ff3defb5399281308", "tags": "IT技术·浏览器", "comment_num": 0, "title": "为什么浏览器的用户代理字符串以 Mozilla 开头", "praise_num": 0, "image_urls": ["http://jbcdn2.b0.upaiyun.com/2018/03/47a58f731472797655f14eeebe80e7d7.png"], "contents": "最早流行的浏览器是 NCSA Mosaic，它称自己为 NCSA_Mosaic/2.0 (Windows 3.1)；后来一个新浏览器出现了，它的名字叫 Mozilla，是 Mosaic Killer 的缩写，Mosaic 并不觉得这好笑，因此该浏览器改名为 Netscape，它称自己为 Mozilla/1.0 (Win3.1)。__Netscape 支持框架（frame），而 Mosaic 不支持，因此用户代理嗅探（User Agent sniffing）出现了，网站在检测到 Mozilla 后就发送框架，如果不是就不发送。后来微软开发了 IE，希望它成为 Netscape Killer，IE 也支持框架，但由于它不是 Mozilla，网站没有向它发送框架。__微软没有耐心等待网站修改而是声称它兼容于 Mozilla，因此冒充 Netscape 称自己为 Mozilla/1.22 (compatible; MSIE 2.0; Windows 95)。第一次浏览器战争以 Netscape 的失利结束，但 Netscape 以 Mozilla 的名字获得了新生。__Mozilla 构建了 Gecko，称自己为 Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.1) Gecko/20020826。Gecko 是一个渲染引擎，Mozilla 在此基础上开发了 Firefox，它称自己为 Mozilla/5.0 (Windows; U; Windows NT 5.1; sv-SE; rv:1.7.5) Gecko/20041108 Firefox/1.0。因为 Gecko 好于 IE，因此用户代理嗅探又出现了，网站在检测到 Gecko 后会提供更好的页面代码。__Linux 上的浏览器 Konqueror 使用的渲染引擎是 KHTM，它只能冒充 Gecko 称自己为 Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko)。Opera 则提供了选项，让用户想冒充哪个浏览器就冒充哪个浏览器。苹果后来创建了 KHTML 的一个分支 WebKit，称自己为 Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5。这就是为什么浏览器的用户代理字符串以 Mozilla 开头。", "url": "http://blog.jobbole.com/113716/", "image_file_path": "full/8f56708c8277db3452adbaf82ed7ad944f9b4ada.jpg", "pubtime": "2018/03/06"}
{"fav_num": 1, "url_object_id": "0ec536e6cc340e779e8be8c764ab39c0", "tags": "IT技术·Linux", "comment_num": 0, "title": "Linux 主目录中的隐藏文件是干什么用的？", "praise_num": 0, "image_urls": ["http://jbcdn2.b0.upaiyun.com/2018/03/c96c574ca76e6b552476e508f1247902.png"], "contents": "在 Linux 系统中，你可能会在主目录中存储了大量文件和文件夹。但在这些文件之外，你知道你的主目录还附带了很多隐藏的文件和文件夹吗？如果你在主目录中运行 __，你会发现一堆带有点前缀的隐藏文件和目录。这些隐藏的文件到底做了什么？__通常，主目录中的隐藏文件和目录包含该用户程序访问的设置或数据。它们不打算让用户编辑，只需要应用程序进行编辑。这就是为什么它们被隐藏在用户的正常视图之外。__通常，删除和修改自己主目录中的文件不会损坏操作系统。然而，依赖这些隐藏文件的应用程序可能不那么灵活。从主目录中删除隐藏文件时，通常会丢失与其关联的应用程序的设置。__依赖该隐藏文件的程序通常会重新创建它。 但是，你将从“开箱即用”设置开始，如全新用户一般。如果你在使用应用程序时遇到问题，那实际上可能是一个巨大的帮助。它可以让你删除可能造成麻烦的自定义设置。但如果你不这样做，这意味着你需要把所有的东西都设置成原来的样子。__每个人在他们的主目录中都会有不同的隐藏文件。每个人都有一些。但是，无论应用程序如何，这些文件都有类似的用途。__系统设置包括桌面环境和 shell 的配置。__你会在 Ubuntu 的 __ 文件夹中找到它们。 这些是针对特定应用程序的设置。 它们将包含喜好列表和设置等内容。__在大多数情况下，你的 Linux 主目录中的隐藏文件用于存储用户设置。 这包括命令行程序以及基于 GUI 的应用程序的设置。删除它们将删除用户设置。 通常情况下，它不会导致程序被破坏。__ ", "url": "http://blog.jobbole.com/113719/", "image_file_path": "full/25fd6361e58d68d4d0e0fe883f9e496afcab090b.jpg", "pubtime": "2018/03/07"}
{"fav_num": 3, "url_object_id": "8dc9c672255230d0cfa267884f1e9bb5", "tags": "IT技术·分布式", "comment_num": 0, "title": "利用 DB 实现分布式锁的思路", "praise_num": 0, "image_urls": ["http://jbcdn2.b0.upaiyun.com/2015/07/8266f93c2d45d97e0d52e71428ca372e.png"], "contents": "以前参加过一个库存系统，由于其业务复杂性，搞了很多个应用来支撑。这样的话一份库存数据就有可能同时有多个应用来修改库存数据。比如说，有定时任务域xx.cron，和SystemA域和SystemB域这几个JAVA应用，可能同时修改同一份库存数据。如果不做协调的话，就会有脏数据出现。对于跨JAVA进程的线程协调，可以借助外部环境，例如DB或者Redis。下文介绍一下如何使用DB来实现分布式锁。__本文设计的分布式锁的交互方式如下：__\n1、根据业务字段生成__，并线程安全的创建锁资源__\n2、根据__申请锁__\n3、释放锁__在使用__关键字的时候，必须指定一个锁对象。__进程内的线程可以基于obj来实现同步。obj在这里可以理解为一个锁对象。如果线程要进入__代码块里，必须先持有obj对象上的锁。这种锁是JAVA里面的内置锁，创建的过程是线程安全的。那么借助DB，如何保证创建锁的过程是线程安全的呢？可以利用DB中的__特性，一旦出现了重复的key，由于__的唯一性，会抛出异常的。在JAVA里面，是__异常。__是事务Id，比如说，可以用__仓库 + 条码 + 销售模式__来组装一个__，表示某仓库某销售模式下的某个条码资源。不同条码，当然就有不同的__。如果有两个应用，拿着相同的__来创建锁资源的时候，只能有一个应用创建成功。__一条__记录插入成功了，就表示一份锁资源创建成功了。__在写操作频繁的业务系统中，通常会进行分库，以降低单数据库写入的压力，并提高写操作的吞吐量。如果使用了分库，那么业务数据自然也都分配到各个数据库上了。在这种水平切分的多数据库上使用DB分布式锁，可以自定义一个__列表。并暴露一个__方法，按照__找到对应的__。__实现代码如下：__首先编写一个__方法，并利用Spring的__注解初始化一个__ 列表。相关的DB配置从__读取。__使用阿里的__。__接着最重要的一个实现__方法。实现原理很简单，获取__的hashcode，并对__的长度取模即可。__连接池列表设计好后，就可以实现往__表插入数据了。__接下来利用DB的__特性来锁住线程。当多个线程根据相同的__并发同时操作__的时候，只有一个线程能成功，其他线程都__住，直到__成功的线程使用__操作后，__住的所有线程的其中一个线程才能开始干活。我们在上面的__类中创建一个__方法。__当线程执行完任务后，必须手动的执行解锁操作，之前被锁住的线程才能继续干活。在我们上面的实现中，其实就是获取到当时__成功的线程对应的__，并实行__操作即可。__那么如何获取到呢？我们可以利用__。首先在__类中定义__每次调用__方法的时候，把__放置到__里面。我们修改__方法。__这样子，当获取到__后，将其设置到__中，如果__方法出现异常，则将其从__中移除掉。__有了这几步后，我们可以来实现解锁操作了。我们在__添加一个__方法。__毕竟是利用DB来实现分布式锁，对DB还是造成一定的压力。当时考虑使用DB做分布式的一个重要原因是，我们的应用是后端应用，平时流量不大的，反而关键的是要保证库存数据的正确性。对于像前端库存系统，比如添加购物车占用库存等操作，最好别使用DB来实现分布式锁了。__如果想锁住多份数据该怎么实现？比如说，某个库存操作，既要修改物理库存，又要修改虚拟库存，想锁住物理库存的同时，又锁住虚拟库存。其实也不是很难，参考__方法，写一个__方法，提供多个__的入参，for循环处理就可以了。这个后续有时间再补上。__\n                        __\n            \n                    ", "url": "http://blog.jobbole.com/113707/", "image_file_path": "full/cd53a2302bc0852583e1e611cf280b011948f392.jpg", "pubtime": "2018/03/09"}
